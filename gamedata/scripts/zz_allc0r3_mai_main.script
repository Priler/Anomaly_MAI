-- MAI (Mutant/Anomaly Interaction) by Priler
-- original idea/mod by AllC0r3, version 2.6


-- [ Local Aliases ]--

local pairs = pairs
local ipairs = ipairs
local type = type
local tostring = tostring
local tonumber = tonumber
local sf = string.find
local sformat = string.format
local tinsert = table.insert
local tconcat = table.concat
local mfloor = math.floor
local mmax = math.max
local mmin = math.min
local mrand = math.random
local mceil = math.ceil


-- [ Module Variables ]--

local anomaly_cache = {}
local cache_valid = false
local cache_level = nil

local global_update_timer = 0
local UPDATE_INTERVAL = 2000

local cached_debug_mode = false
local cached_verbose_debug = false
local cached_mod_enabled = true
local cached_show_debug_anomalies = false

local debug_anomalies_shown = false

local npc_last_update = {}
local npc_restrictions = {}
local npc_last_anomaly = {}

local ANOMALY_ATTRIBUTION_TIMEOUT = 5000
local MAX_RESTRICTIONS_PER_NPC = 30


-- [ Safe Wrappers ]--

local function safe_call(func, ...)
    local ok, result = pcall(func, ...)
    if ok then return result end
    return nil
end

local function is_valid_object(obj)
    if not obj then return false end
    if type(obj.id) ~= "function" then return false end
    local id = safe_call(obj.id, obj)
    if not id or id == 65535 then return false end
    return true
end

local function is_valid_stalker(obj)
    if not is_valid_object(obj) then return false end
    local is_stalker = safe_call(IsStalker, obj)
    if not is_stalker then return false end
    local alive = safe_call(obj.alive, obj)
    return alive == true
end

local function get_position_copy(obj)
    if not is_valid_object(obj) then return nil end
    local pos = safe_call(obj.position, obj)
    if not pos then return nil end
    return vector():set(pos.x, pos.y, pos.z)
end


-- [ MCM Integration ]--

local function get_mcm_setting(key, default)
    if zz_allc0r3_mai_mcm then
        local getter = zz_allc0r3_mai_mcm["get_config"]
        if getter then
            local val = getter(key)
            if val ~= nil then return val end
        end
    end
    return default
end

local function is_mod_enabled() return cached_mod_enabled end
function is_debug_enabled() return cached_debug_mode end
local function is_verbose_debug() return cached_verbose_debug end
local function should_show_debug_anomalies() return cached_show_debug_anomalies end

local function update_mcm_cache()
    cached_mod_enabled = get_mcm_setting("mod_enabled", true)
    cached_debug_mode = get_mcm_setting("debug_mode", false)
    cached_verbose_debug = get_mcm_setting("verbose_debug", false)
    cached_show_debug_anomalies = get_mcm_setting("show_debug_anomalies", false)
end


-- [ Debug Logging ]--

local function dbg_log(category, format, ...)
    if not is_debug_enabled() then return end
    local msg = sformat(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end

local function dbg_verbose(category, format, ...)
    if not is_verbose_debug() then return end
    local msg = sformat(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end


-- [ Arrival Mod Compatibility ]--

local arrival_checked = false
local arrival_loaded = false

local function is_arrival_loaded()
    if not arrival_checked then
        arrival_loaded = arrival_zone_disable ~= nil and 
                        arrival_zone_disable.zd_spawn and
                        arrival_zone_disable.zd_spawn.zones_to_disable
        arrival_checked = true
    end
    return arrival_loaded
end

local function is_arrival_anomaly_active(anom_id, level_name)
    if not is_arrival_loaded() then return true end
    
    local zones_to_disable = arrival_zone_disable.zd_spawn.zones_to_disable
    if not zones_to_disable then return true end
    
    local level_zones = zones_to_disable[level_name]
    if not level_zones then return true end
    
    return not level_zones[anom_id]
end


-- [ Anomaly Cache ]--

local ignored_anomalies_hash = nil
local ignored_anomalies_patterns = nil

local function init_ignored_anomalies()
    if ignored_anomalies_hash then return end
    
    ignored_anomalies_hash = {}
    ignored_anomalies_patterns = {}
    
    if not zz_allc0r3_mai_anomalies_settings then return end
    local t = zz_allc0r3_mai_anomalies_settings.mai_always_ignore_anom
    if not t then return end
    
    for i = 1, #t do
        local entry = t[i]
        if entry:match("_%d+$") then
            ignored_anomalies_hash[entry] = true
        else
            tinsert(ignored_anomalies_patterns, entry)
        end
    end
end

local function is_always_skip_anomaly(anom_name)
    if not anom_name then return true end
    init_ignored_anomalies()
    
    if ignored_anomalies_hash[anom_name] then return true end
    
    for i = 1, #ignored_anomalies_patterns do
        if sf(anom_name, ignored_anomalies_patterns[i]) then return true end
    end
    
    return false
end

local function rebuild_anomaly_cache()
    anomaly_cache = {}
    
    local lvl_name = level.name()
    if not lvl_name then
        cache_valid = true
        return
    end
    cache_level = lvl_name
    
    local fields = bind_anomaly_field and bind_anomaly_field.fields_by_names
    if not fields then 
        dbg_verbose("CACHE", "No anomaly fields found")
        cache_valid = true
        return 
    end
    
    local count = 0
    local skipped = 0
    local arrival_loaded_now = is_arrival_loaded()
    local dyn_anomalies = bind_anomaly_field.dyn_anomalies
    local dyn_anomalies_level = dyn_anomalies and dyn_anomalies[lvl_name]
    
    for _, v in pairs(fields) do
        local anom_obj = v and v.object
        if anom_obj then
            local anom_id = safe_call(anom_obj.id, anom_obj)
            if anom_id and anom_id ~= 65535 then
                local se_obj = alife_object(anom_id)
                
                if se_obj then
                    local anom_name = safe_call(se_obj.name, se_obj)
                    
                    if not anom_name or is_always_skip_anomaly(anom_name) then
                        skipped = skipped + 1
                    else
                        local is_active = true
                        
                        if arrival_loaded_now then
                            is_active = is_arrival_anomaly_active(anom_id, lvl_name)
                        end
                        
                        if is_active and dyn_anomalies_level then
                            local dyn_state = dyn_anomalies_level[anom_id]
                            if dyn_state == false then
                                is_active = false
                            end
                        end
                        
                        if is_active then
                            local pos = safe_call(anom_obj.position, anom_obj)
                            if pos and pos.x and pos.y and pos.z then
                                local section = safe_call(se_obj.section_name, se_obj) or "unknown"
                                tinsert(anomaly_cache, {
                                    id = anom_id,
                                    name = anom_name,
                                    pos = vector():set(pos.x, pos.y, pos.z),
                                    section = section
                                })
                                count = count + 1
                            else
                                skipped = skipped + 1
                            end
                        else
                            skipped = skipped + 1
                        end
                    end
                end
            end
        end
    end
    
    cache_valid = true
    dbg_log("CACHE", "Rebuilt: %d anomalies on %s (skipped %d)", count, lvl_name, skipped)
end

local function invalidate_cache()
    cache_valid = false
end

local function ensure_cache()
    local current_level = level.name()
    if not cache_valid or cache_level ~= current_level then
        rebuild_anomaly_cache()
        
        -- refresh debug markers if needed
        if cached_show_debug_anomalies then
            CreateTimeEvent("mai_debug_markers", "refresh", 0.5, function()
                if cached_show_debug_anomalies and cache_valid then
                    local count = 0
                    for _, anom in ipairs(anomaly_cache) do
                        if level.map_has_object_spot(anom.id, "anomaly_disabled") ~= 0 then
                            level.map_remove_object_spot(anom.id, "anomaly_disabled")
                        end
                        local marker_text = sformat("MAI: %s\\n%s", anom.name, anom.section)
                        level.map_add_object_spot_ser(anom.id, "anomaly_disabled", marker_text)
                        count = count + 1
                    end
                    debug_anomalies_shown = true
                    dbg_log("DEBUG", "Refreshed %d anomaly markers on map", count)
                end
                return true
            end)
        end
    end
end


-- [ NPC Checks ]--

local function is_ignore_npc(npc)
    local id = npc:id()
    local section = npc:section()
    local profile = npc:profile_name()
    
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[section] then
        dbg_verbose("IGNORE", "NPC [%s] ignored by section [%s]", npc:name(), section)
        return true
    end
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[profile] then
        dbg_verbose("IGNORE", "NPC [%s] ignored by profile [%s]", npc:name(), profile)
        return true
    end
    if get_object_story_id(id) then
        dbg_verbose("IGNORE", "NPC [%s] ignored by story_id [%s]", npc:name(), get_object_story_id(id))
        return true
    end
    if IsTrader(npc) then
        dbg_verbose("IGNORE", "NPC [%s] ignored - is trader", npc:name())
        return true
    end
    return false
end

local function is_companion_npc(npc)
    -- if not is_valid_object(npc) then return false end
    -- local has_info = safe_call(npc.has_info, npc, "npcx_is_companion")
    -- return has_info == true
    if not npc then return false end
    return npc:has_info("npcx_is_companion")
end

local function is_task_target_npc(npc)
    if not npc then return false end
    
    -- Check story ID - story NPCs are quest-critical and should be protected
    local npc_id = npc:id()
    if get_object_story_id and get_object_story_id(npc_id) then
        return true
    end
    
    -- Check if NPC has escort infoportion
    if npc:has_info("npcx_beh_escort_target") then
        return true
    end
    
    return false
end

local function get_npc_community(npc)
    if not is_valid_object(npc) then return nil end
    return safe_call(npc.character_community, npc)
end

local function should_enable_anomaly_damage(npc)
    if not is_valid_stalker(npc) then return false, "invalid" end
    if npc:id() == 0 then return true, "actor" end
    
    local community = get_npc_community(npc)
    if not community then return true, "no_community" end
    
    if not zz_allc0r3_mai_npc_settings then return true, "no_settings" end
    
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community and
       zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false, "full_ignore_community"
    end
    
    if zz_allc0r3_mai_npc_settings.mai_no_damage_community and
       zz_allc0r3_mai_npc_settings.mai_no_damage_community[community] then
        return false, "no_damage_community"
    end
    
    if is_ignore_npc(npc) then return false, "ignore_npc" end
    if is_companion_npc(npc) then return false, "companion" end
    if is_task_target_npc(npc) then return false, "task_target" end
    
    if get_mcm_setting("immune_zero_miss_chance", true) then
        local base_miss = get_rank_miss_chance(npc)
        if base_miss <= 0 then
            return false, "immune_zero_miss"
        end
    end
    
    return true, "normal"
end

local function should_add_restrictions(npc)
    if not is_valid_stalker(npc) then return false end
    
    local community = get_npc_community(npc)
    if not community then return true end
    
    if not zz_allc0r3_mai_npc_settings then return true end
    
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community and
       zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false
    end
    
    if zz_allc0r3_mai_npc_settings.mai_no_evade_community and
       zz_allc0r3_mai_npc_settings.mai_no_evade_community[community] then
        return false
    end
    
    if is_ignore_npc(npc) then return false end
    if is_companion_npc(npc) then return false end
    if is_task_target_npc(npc) then return false end
    
    return true
end


-- [ NPC Anomaly Config ]--

local function configure_npc_anomaly_interaction(npc)
    if not is_valid_stalker(npc) then return end
    
    local should_damage, reason = should_enable_anomaly_damage(npc)
    safe_call(npc.set_enable_anomalies_damage, npc, should_damage)
    safe_call(npc.set_enable_anomalies_pathfinding, npc, true)
    
    dbg_verbose("CONFIG", "NPC [%s] damage=%s (%s)", 
        npc:name() or "?", tostring(should_damage), reason)
end


-- [ Rank & Movement ]--

local RANK_MCM_KEYS = {
    ["novice"] = "rank_novice_miss_chance",
    ["trainee"] = "rank_trainee_miss_chance",
    ["experienced"] = "rank_experienced_miss_chance",
    ["professional"] = "rank_professional_miss_chance",
    ["veteran"] = "rank_veteran_miss_chance",
    ["expert"] = "rank_expert_miss_chance",
    ["master"] = "rank_master_miss_chance",
    ["legend"] = "rank_legend_miss_chance"
}

local RANK_DEFAULTS = {
    ["novice"] = 100,
    ["trainee"] = 75,
    ["experienced"] = 50,
    ["professional"] = 25,
    ["veteran"] = 0,
    ["expert"] = 0,
    ["master"] = 0,
    ["legend"] = 0
}

function get_rank_miss_chance(npc)
    if not is_valid_object(npc) then return 50 end
    
    local rank = nil
    if ranks and ranks.get_obj_rank_name then
        rank = safe_call(ranks.get_obj_rank_name, npc)
    end
    if not rank then rank = "novice" end
    
    local setting_key = RANK_MCM_KEYS[rank] or "rank_novice_miss_chance"
    local default_val = RANK_DEFAULTS[rank] or 100
    
    return get_mcm_setting(setting_key, default_val)
end

local function get_movement_state_multiplier(npc)
    if not is_valid_object(npc) then return 1.0 end
    
    local has_enemy = false
    local best_enemy = safe_call(npc.best_enemy, npc)
    if best_enemy then has_enemy = true end
    
    if has_enemy then
        return get_mcm_setting("combat_miss_multiplier", 2.5)
    end
    
    local movement = safe_call(npc.movement_type, npc)
    if not movement then return 1.0 end
    
    if movement == move.stand then
        return get_mcm_setting("standing_miss_multiplier", 0.3)
    elseif movement == move.walk then
        return get_mcm_setting("walking_miss_multiplier", 0.7)
    elseif movement == move.run then
        return get_mcm_setting("running_miss_multiplier", 1.3)
    end
    
    return 1.0
end

local function get_movement_state_name(npc)
    if not is_valid_object(npc) then return "unknown" end
    
    local best_enemy = safe_call(npc.best_enemy, npc)
    if best_enemy then return "combat" end
    
    local movement = safe_call(npc.movement_type, npc)
    if not movement then return "unknown" end
    
    if movement == move.stand then return "standing"
    elseif movement == move.walk then return "walking"
    elseif movement == move.run then return "running"
    end
    return "unknown"
end


-- [ Distance Checks ]--

local function get_nearby_anomalies(npc_pos, radius)
    if not npc_pos then return {} end
    local result = {}
    
    for _, anom in ipairs(anomaly_cache) do
        if anom.pos then
            local dist = npc_pos:distance_to(anom.pos)
            if dist <= radius then
                tinsert(result, anom)
            end
        end
    end
    
    return result
end

local function get_closest_anomaly(npc_pos)
    if not npc_pos then return nil, 99999 end
    
    local closest = nil
    local closest_dist = 99999
    
    for _, anom in ipairs(anomaly_cache) do
        if anom.pos then
            local dist = npc_pos:distance_to(anom.pos)
            if dist < closest_dist then
                closest_dist = dist
                closest = anom
            end
        end
    end
    
    return closest, closest_dist
end


-- [ Restriction Management ]--

local function clear_npc_restrictions(npc)
    if not is_valid_object(npc) then return end
    
    local id = npc:id()
    local current = safe_call(npc.in_restrictions, npc) or ""
    
    if current ~= "" then
        safe_call(npc.remove_restrictions, npc, "", current)
        dbg_verbose("RESTRICT", "Cleared restrictions for [%s]", npc:name() or "?")
    end
    
    npc_restrictions[id] = nil
end

local function update_npc_restrictions(npc, detection_radius)
    if not should_add_restrictions(npc) then return end
    if not is_valid_stalker(npc) then return end
    
    local id = npc:id()
    local current_time = time_global()
    
    if npc_last_update[id] and current_time - npc_last_update[id] < 1500 then
        return
    end
    npc_last_update[id] = current_time
    
    local npc_pos = get_position_copy(npc)
    if not npc_pos then return end
    
    local radius = detection_radius or get_mcm_setting("base_detection_radius", 30)
    local nearby = get_nearby_anomalies(npc_pos, radius)
    
    if #nearby == 0 then
        if npc_restrictions[id] then
            clear_npc_restrictions(npc)
        end
        return
    end
    
    local miss_chance = get_rank_miss_chance(npc)
    local state_mult = get_movement_state_multiplier(npc)
    local final_miss = mfloor(miss_chance * state_mult)
    final_miss = mmax(0, mmin(100, final_miss))
    
    local detected = {}
    local rank = "unknown"
    if ranks and ranks.get_obj_rank_name then
        rank = safe_call(ranks.get_obj_rank_name, npc) or "unknown"
    end
    local state = get_movement_state_name(npc)
    
    for _, anom in ipairs(nearby) do
        local immune_zero = get_mcm_setting("immune_zero_miss_chance", true)
        
        if immune_zero and final_miss <= 0 then
            tinsert(detected, anom.name)
        else
            local roll = mrand(1, 100)
            if roll > final_miss then
                tinsert(detected, anom.name)
                dbg_log("DETECT", "[%s] (%s) detected [%s] (roll %d > %d%%)", 
                    npc:name() or "?", rank, anom.name, roll, final_miss)
            else
                dbg_verbose("DETECT", "[%s] (%s) missed [%s] (roll %d <= %d%%)", 
                    npc:name() or "?", rank, anom.name, roll, final_miss)
            end
        end
        
        if #detected >= MAX_RESTRICTIONS_PER_NPC then
            break
        end
    end
    
    if #detected > 0 then
        clear_npc_restrictions(npc)
        
        local add_str = tconcat(detected, ",")
        safe_call(npc.add_restrictions, npc, "", add_str)
        npc_restrictions[id] = detected
        
        dbg_verbose("RESTRICT", "[%s] added %d restrictions", npc:name() or "?", #detected)
    end
end


-- [ Anomaly Before Activate ]--

local function on_anomaly_before_activate(zone, obj, flags)
    if not is_mod_enabled() then return end
    if not obj then return end
    
    local obj_id = safe_call(obj.id, obj)
    if not obj_id or obj_id == 0 then return end
    
    local is_stalker = safe_call(IsStalker, obj)
    if not is_stalker then return end
    
    if get_mcm_setting("block_anomalies_on_corpses", true) then
        local alive = safe_call(obj.alive, obj)
        if not alive then
            flags.ret_value = false
            return
        end
    else
        local alive = safe_call(obj.alive, obj)
        if not alive then return end
    end
    
    if surge_started() then return end
    
    local should_damage, reason = should_enable_anomaly_damage(obj)
    
    if not should_damage then
        flags.ret_value = false
        dbg_verbose("BLOCK", "Blocked [%s] from [%s] (%s)", 
            zone:name() or "?", obj:name() or "?", reason)
        return
    end
    
    local zone_name = safe_call(zone.name, zone) or "unknown"
    local zone_section = safe_call(zone.section, zone) or "unknown"
    local rank = "unknown"
    if ranks and ranks.get_obj_rank_name then
        rank = safe_call(ranks.get_obj_rank_name, obj) or "unknown"
    end
    local state = get_movement_state_name(obj)
    local community = get_npc_community(obj) or "unknown"
    
    dbg_log("DAMAGE", "[%s] (%s %s) walked into [%s]", 
        obj:name() or "?", rank, state, zone_name)
    
    npc_last_anomaly[obj_id] = {
        name = zone_name,
        section = zone_section,
        time = time_global(),
        state = state,
        rank = rank,
        community = community
    }
end


-- [ NPC Before Hit (Armor) ]--

local ANOMALY_PROTECTION_PATTERNS = {
    { pattern = "electra",      protection = "shock_protection" },
    { pattern = "electric",     protection = "shock_protection" },
    { pattern = "tesla",        protection = "shock_protection" },
    { pattern = "static",       protection = "shock_protection" },
    { pattern = "burner",       protection = "burn_protection" },
    { pattern = "thermal",      protection = "burn_protection" },
    { pattern = "fire",         protection = "burn_protection" },
    { pattern = "inferno",      protection = "burn_protection" },
    { pattern = "zharka",       protection = "burn_protection" },
    { pattern = "acidic",       protection = "chemical_burn_protection" },
    { pattern = "chemical",     protection = "chemical_burn_protection" },
    { pattern = "gas",          protection = "chemical_burn_protection" },
    { pattern = "fruit_punch",  protection = "chemical_burn_protection" },
    { pattern = "gravitational", protection = "strike_protection" },
    { pattern = "springboard",   protection = "strike_protection" },
    { pattern = "vortex",        protection = "strike_protection" },
    { pattern = "whirligig",     protection = "strike_protection" },
    { pattern = "galantine",     protection = "strike_protection" },
    { pattern = "tramplin",      protection = "strike_protection" },
    { pattern = "radioactive",  protection = "radiation_protection" },
    { pattern = "radiation",    protection = "radiation_protection" },
    { pattern = "psy",          protection = "telepatic_protection" },
    { pattern = "brain",        protection = "telepatic_protection" },
    { pattern = "telepatic",    protection = "telepatic_protection" },
}

local anomaly_protection_cache = {}

local function get_anomaly_protection_type(anomaly_section)
    if not anomaly_section then return nil end
    
    local cached = anomaly_protection_cache[anomaly_section]
    if cached ~= nil then
        return cached ~= false and cached or nil
    end
    
    local section_lower = anomaly_section:lower()
    for _, mapping in ipairs(ANOMALY_PROTECTION_PATTERNS) do
        if sf(section_lower, mapping.pattern) then
            anomaly_protection_cache[anomaly_section] = mapping.protection
            return mapping.protection
        end
    end
    
    anomaly_protection_cache[anomaly_section] = false
    return nil
end

local function get_npc_outfit_protection(npc, protection_type)
    if not is_valid_object(npc) or not protection_type then return 0 end
    
    local outfit = safe_call(npc.item_in_slot, npc, 7)
    if not outfit then return 0 end
    
    local outfit_section = safe_call(outfit.section, outfit)
    if not outfit_section then return 0 end
    
    local protection = SYS_GetParam(2, outfit_section, protection_type, 0)
    return protection or 0
end

function get_npc_dmg_mult(npc, anomaly)
    if not is_valid_object(npc) then return 1.0 end
    if not get_mcm_setting("enable_armor_damage_mult", true) then return 1.0 end
    if not anomaly then return 1.0 end
    
    local anomaly_section = safe_call(anomaly.section, anomaly)
    if not anomaly_section then return 1.0 end
    
    local protection_type = get_anomaly_protection_type(anomaly_section)
    if not protection_type then return 1.0 end
    
    local protection = get_npc_outfit_protection(npc, protection_type)
    local damage_mult = mmax(0, 1.0 - protection)
    
    dbg_verbose("ARMOR", "[%s] → %s → prot %.2f → mult %.2f",
        anomaly_section, protection_type, protection, damage_mult)
    
    return damage_mult
end

local function on_npc_before_hit(npc, shit, bone_id, flags)
    if not is_mod_enabled() then return end
    if not npc or not shit then return end
    
    local alive = safe_call(npc.alive, npc)
    if not alive then return end
    
    local is_stalker = safe_call(IsStalker, npc)
    if not is_stalker then return end
    
    local who = shit.draftsman
    if not who then return end
    
    local is_anomaly = false
    if who.is_anomaly then
        is_anomaly = safe_call(who.is_anomaly, who)
    end
    if not is_anomaly then return end
    
    if get_mcm_setting("enable_armor_damage_mult", true) then
        local mult = get_npc_dmg_mult(npc, who)
        if mult < 1.0 then
            shit.power = shit.power * mult
        end
    end
end


-- [ Surge Detection ]--

function surge_started()
    local surge_active = surge_manager and surge_manager.is_loaded and 
                        surge_manager.is_loaded() and surge_manager.is_started and
                        surge_manager.is_started()
    local psy_active = psi_storm_manager and psi_storm_manager.is_loaded and
                      psi_storm_manager.is_loaded() and psi_storm_manager.is_started and
                      psi_storm_manager.is_started()
    return surge_active or psy_active
end


-- [ Death Detection ]--

local FACTION_NAMES = {
    ["stalker"] = "Loner",
    ["bandit"] = "Bandit",
    ["dolg"] = "Duty",
    ["freedom"] = "Freedom",
    ["monolith"] = "Monolith",
    ["army"] = "Military",
    ["ecolog"] = "Ecologist",
    ["killer"] = "Mercenary",
    ["greh"] = "Sin",
    ["renegade"] = "Renegade",
    ["isg"] = "ISG",
    ["csky"] = "Clear Sky",
    ["zombied"] = "Zombie",
}

local function get_faction_name(community)
    if not community then return "Unknown" end
    return FACTION_NAMES[community] or community
end

local function report_anomaly_death(npc, anomaly_info)
    if not is_debug_enabled() then return end
    if not is_valid_object(npc) then return end
    
    local victim_name = npc:name() or "unknown"
    local faction_name = get_faction_name(anomaly_info.community)
    local victim_rank = anomaly_info.rank or "unknown"
    local victim_state = anomaly_info.state or "unknown"
    
    printf("[MAI][DEATH] %s (%s %s) killed by %s (%s) while %s", 
        victim_name, victim_rank, faction_name, 
        anomaly_info.name, anomaly_info.section, victim_state)
    
    if db.actor then
        local news_text = sformat("%s (%s %s) killed by %s while %s", 
            victim_name, victim_rank, faction_name, 
            anomaly_info.section, victim_state)
        db.actor:give_game_news("MAI: Anomaly Kill", news_text, "ui_inGame2_PD_Dengi", 0, 5000, 0)
    end
end

local function check_anomaly_deaths(current_time)
    local to_remove = {}
    
    for npc_id, anomaly_info in pairs(npc_last_anomaly) do
        if (current_time - anomaly_info.time) > ANOMALY_ATTRIBUTION_TIMEOUT then
            tinsert(to_remove, npc_id)
        else
            local npc = level.object_by_id(npc_id)
            if npc then
                local alive = safe_call(npc.alive, npc)
                if not alive and not anomaly_info.reported then
                    anomaly_info.reported = true
                    report_anomaly_death(npc, anomaly_info)
                    tinsert(to_remove, npc_id)
                end
            else
                tinsert(to_remove, npc_id)
            end
        end
    end
    
    for _, npc_id in ipairs(to_remove) do
        npc_last_anomaly[npc_id] = nil
    end
end


-- [ Level Check ]--

local function is_ignore_level()
    local current_level = level.name()
    if not current_level then return true end
    
    if not zz_allc0r3_mai_location_settings then return false end
    local ignore_levels = zz_allc0r3_mai_location_settings.mai_always_ignore_levels
    if not ignore_levels then return false end
    
    return ignore_levels[current_level] == true
end


-- [ Main Update Loop ]--

local function on_actor_update()
    if not is_mod_enabled() then return end
    if surge_started() then return end
    if not db.actor then return end
    if is_ignore_level() then return end
    
    local current_time = time_global()
    if current_time < global_update_timer then return end
    global_update_timer = current_time + UPDATE_INTERVAL
    
    check_anomaly_deaths(current_time)
    ensure_cache()
    
    local effect_radius = get_mcm_setting("effect_radius", 300)
    local restrictions_ignore_radius = get_mcm_setting("restrictions_ignore_radius", true)
    local detection_radius = get_mcm_setting("base_detection_radius", 30)
    local actor_pos = get_position_copy(db.actor)
    
    if not actor_pos then return end
    
    local processed = 0
    
    for id, npc in pairs(db.OnlineStalkers or {}) do
        if type(npc) == "number" then
            npc = level.object_by_id(npc)
        end
        
        if is_valid_stalker(npc) then
            local npc_pos = get_position_copy(npc)
            if npc_pos then
                local distance = npc_pos:distance_to(actor_pos)
                local within_radius = distance <= effect_radius
                
                if within_radius then
                    configure_npc_anomaly_interaction(npc)
                else
                    safe_call(npc.set_enable_anomalies_damage, npc, false)
                end
                
                if within_radius or restrictions_ignore_radius then
                    update_npc_restrictions(npc, detection_radius)
                end
                
                processed = processed + 1
            end
        end
    end
    
    if processed > 0 then
        dbg_verbose("UPDATE", "Processed %d NPCs (cache: %d anomalies)", 
            processed, #anomaly_cache)
    end
end


-- [ Debug Map Markers ]--

function show_debug_anomaly_markers()
    if not db.actor then return end
    
    ensure_cache()
    
    local count = 0
    for _, anom in ipairs(anomaly_cache) do
        local id = anom.id
        if level.map_has_object_spot(id, "anomaly_disabled") ~= 0 then
            level.map_remove_object_spot(id, "anomaly_disabled")
        end
        local marker_text = sformat("MAI: %s\\n%s", anom.name, anom.section)
        level.map_add_object_spot_ser(id, "anomaly_disabled", marker_text)
        count = count + 1
    end
    
    debug_anomalies_shown = true
    dbg_log("DEBUG", "Showing %d anomaly markers on map", count)
end

function hide_debug_anomaly_markers()
    local count = 0
    
    if cache_valid and #anomaly_cache > 0 then
        for _, anom in ipairs(anomaly_cache) do
            if level.map_has_object_spot(anom.id, "anomaly_disabled") ~= 0 then
                level.map_remove_object_spot(anom.id, "anomaly_disabled")
                count = count + 1
            end
        end
    else
        -- fallback scan
        for i = 1, 100000 do
            if level.map_has_object_spot(i, "anomaly_disabled") ~= 0 then
                level.map_remove_object_spot(i, "anomaly_disabled")
                count = count + 1
            end
        end
    end
    
    debug_anomalies_shown = false
    if count > 0 then
        dbg_log("DEBUG", "Removed %d anomaly markers from map", count)
    end
end

local function cleanup_old_map_markers()
    dbg_log("CLEANUP", "Manual cleanup requested, scanning all IDs...")
    local count = 0
    for i = 1, 100000 do
        if level.map_has_object_spot(i, "anomaly_disabled") ~= 0 then
            level.map_remove_object_spot(i, "anomaly_disabled")
            count = count + 1
        end
    end
    if count > 0 then
        dbg_log("CLEANUP", "Cleaned up %d map markers", count)
    else
        dbg_log("CLEANUP", "No markers found to clean up")
    end
    return count
end


-- [ Public API ]--

function invalidate_anomaly_cache()
    invalidate_cache()
    dbg_log("CACHE", "Cache invalidated by external call")
end

function rebuild_anomaly_cache_now()
    invalidate_cache()
    rebuild_anomaly_cache()
end


-- [ Event Callbacks ]--

local function schedule_cache_rebuild(reason)
    local delay = get_mcm_setting("cache_rebuild_delay", 2.5)
    dbg_verbose("EVENT", "%s, scheduling rebuild in %.1fs", reason, delay)
    
    RemoveTimeEvent("mai_cache_rebuild", "mai_cache_rebuild")
    
    if delay <= 0 then
        invalidate_cache()
        return
    end
    
    CreateTimeEvent("mai_cache_rebuild", "mai_cache_rebuild", delay, function()
        invalidate_cache()
        return true
    end)
end

local function on_surge_end()
    schedule_cache_rebuild("Surge ended")
end

local function on_psy_storm_end()
    schedule_cache_rebuild("Psy-storm ended")
end

local function on_actor_interaction(typ, obj, name)
    if typ ~= "anomalies" then return end
    
    if name == "emission_end" then
        schedule_cache_rebuild("Emission ended")
    elseif name == "psi_storm_end" then
        schedule_cache_rebuild("Psi-storm ended")
    end
end

local function on_game_load()
    dbg_verbose("EVENT", "Game loaded")
    
    safe_call(exec_console_cmd, "ai_die_in_anomaly 1")
    
    invalidate_cache()
    npc_last_update = {}
    npc_restrictions = {}
    npc_last_anomaly = {}
    anomaly_protection_cache = {}
end

local function on_level_changed()
    dbg_verbose("EVENT", "Level changed")
    invalidate_cache()
    npc_last_update = {}
    npc_restrictions = {}
    npc_last_anomaly = {}
end

local function on_npc_net_destroy(npc)
    local id
    if type(npc) == "number" then
        id = npc
    elseif is_valid_object(npc) then
        id = npc:id()
        
        local current = safe_call(npc.in_restrictions, npc) or ""
        if current ~= "" then
            safe_call(npc.remove_restrictions, npc, "", current)
        end
    else
        return
    end
    
    npc_last_update[id] = nil
    npc_restrictions[id] = nil
    npc_last_anomaly[id] = nil
end

local function on_npc_net_spawn(npc)
    if not is_mod_enabled() then return end
    if not is_valid_stalker(npc) then return end
    if is_ignore_level() then return end
    
    configure_npc_anomaly_interaction(npc)
end

local function on_option_change()
    local old_show_debug = cached_show_debug_anomalies
    update_mcm_cache()
    
    if get_mcm_setting("cleanup_map_markers", false) then
        cleanup_old_map_markers()
    end
    
    if cached_show_debug_anomalies ~= old_show_debug then
        if cached_show_debug_anomalies then
            show_debug_anomaly_markers()
        else
            hide_debug_anomaly_markers()
        end
    end
end


-- [ Init ]--

function on_game_start()
    update_mcm_cache()
    
    RegisterScriptCallback("actor_on_update", on_actor_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("npc_on_net_destroy", on_npc_net_destroy)
    RegisterScriptCallback("npc_on_net_spawn", on_npc_net_spawn)
    RegisterScriptCallback("anomaly_on_before_activate", on_anomaly_before_activate)
    RegisterScriptCallback("npc_on_before_hit", on_npc_before_hit)
    RegisterScriptCallback("actor_on_interaction", on_actor_interaction)
    RegisterScriptCallback("surge_manager_end_surge", on_surge_end)
    RegisterScriptCallback("psi_storm_manager_end_storm", on_psy_storm_end)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_first_update", on_game_load)
    RegisterScriptCallback("on_level_changing", on_level_changed)
    
    local arrival_status = is_arrival_loaded() and "detected" or "not detected"
    dbg_log("INIT", "MAI v2.6 loaded - enabled=%s, debug=%s, Arrival: %s", 
        tostring(cached_mod_enabled), tostring(cached_debug_mode), arrival_status)
end
