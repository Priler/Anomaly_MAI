--[[
    MAI (Mutant/Anomaly Interaction) by AllC0r3
    Rework of ogse_anomaly_evader.script from OLR 3.0
    Version: 2.0 (MCM Support)
    
    Features:
    - NPC anomaly detection and evasion
    - Faction/rank based detection settings
    - Armor-based damage multipliers
    - MCM configuration support
    - Comprehensive debug logging
--]]

--------------------------------------------------------------------------------
-- Local aliases for performance
--------------------------------------------------------------------------------

local sf = string.find
local ti = table.insert
local tc = table.concat
local tg = table.getn
local sn = script_name()
local rd = math.random

--------------------------------------------------------------------------------
-- Module variables
--------------------------------------------------------------------------------

local mai_npc_settings_file = ini_file("plugins\\mai\\mai_visual_settings.ltx")

npc_count = 0
mai_mob_session = {}
mai_quest_mob_stor = {}
mai_npc_settings_by_visual = {}

-- Debug flag cache (updated from MCM)
local cached_debug_mode = false
local cached_mod_enabled = true

--------------------------------------------------------------------------------
-- MCM Integration
--------------------------------------------------------------------------------

local function get_mcm_setting(key, default)
    if zz_allc0r3_mai_mcm then
        local getter = zz_allc0r3_mai_mcm["get_config"]
        if getter then
            local val = getter(key)
            if val ~= nil then return val end
        end
    end
    return default
end

local function is_mod_enabled() return cached_mod_enabled end
local function is_debug_enabled() return cached_debug_mode end

local function update_mcm_cache()
    cached_mod_enabled = get_mcm_setting("mod_enabled", true)
    cached_debug_mode = get_mcm_setting("debug_mode", false)
end

--------------------------------------------------------------------------------
-- Debug Logging System
--------------------------------------------------------------------------------

function dbg_log(category, format, ...)
    if not is_debug_enabled() then return end
    local msg = string.format(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end

function dbg_subscribe(format, ...)
    if get_mcm_setting("debug_log_subscriptions", true) then
        dbg_log("SUBSCRIBE", format, ...)
    end
end

function dbg_restrict(format, ...)
    if get_mcm_setting("debug_log_restrictions", true) then
        dbg_log("RESTRICT", format, ...)
    end
end

function dbg_damage(format, ...)
    if get_mcm_setting("debug_log_damage", true) then
        dbg_log("DAMAGE", format, ...)
    end
end

function dbg_detect(format, ...)
    if get_mcm_setting("debug_log_detection", false) then
        dbg_log("DETECT", format, ...)
    end
end

function _dbg_printf(str, ...)
    if is_debug_enabled() then printf(str, ...) end
end

--------------------------------------------------------------------------------
-- Core Functions
--------------------------------------------------------------------------------

function mai_npc_anomalies_interaction(npc, pathfinding, damage)
    npc:set_enable_anomalies_damage(damage)
    dbg_detect("Set anomaly damage for NPC [%s]: %s", npc:name(), tostring(damage))
end

function mai_subscribe(obj, _type, text, force)
    if not is_mod_enabled() then
        dbg_subscribe("Mod disabled, skipping subscribe")
        return
    end
    if not obj then return end
    
    local cur_level = level.name()
    
    if _type == "npc" then
        if not obj:alive() then
            dbg_subscribe("Skipping dead NPC [%s]", obj:name())
            return
        end
        
        -- Skip during surge unless forced
        if not force and surge_started() then
            dbg_subscribe("Surge active, skipping [%s]", obj:name())
            mai_npc_anomalies_interaction(obj, false, false)
            return
        end
        
        -- Check if level should be ignored
        if zz_allc0r3_mai_location_settings.mai_always_ignore_levels[cur_level] then
            dbg_subscribe("Level [%s] ignored, skipping [%s]", cur_level, obj:name())
            mai_npc_anomalies_interaction(obj, false, false)
            return
        end
        
        local community = obj:character_community()
        
        -- Check if community should be fully ignored
        if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
            dbg_subscribe("Community [%s] fully ignored, skipping [%s]", community, obj:name())
            mai_npc_anomalies_interaction(obj, false, false)
            return
        end
        
        -- Check if community should ignore pathfinding but take damage
        if zz_allc0r3_mai_npc_settings.mai_always_damage_ignore_community[community] then
            dbg_subscribe("Community [%s] damage-only, skipping evasion for [%s]", community, obj:name())
            mai_npc_anomalies_interaction(obj, false, true)
            return
        end
        
        -- Check for special NPC types
        if is_ignore_npc(obj) then
            dbg_subscribe("NPC [%s] in ignore list", obj:name())
            mai_npc_anomalies_interaction(obj, false, false)
            return
        end
        
        if is_companion_npc(obj) then
            dbg_subscribe("NPC [%s] is companion", obj:name())
            mai_npc_anomalies_interaction(obj, false, false)
            return
        end
        
        if is_task_npc(obj) then
            dbg_subscribe("NPC [%s] is task giver", obj:name())
            mai_npc_anomalies_interaction(obj, false, false)
            return
        end
        
        -- Initialize session data
        local id = obj:id()
        local settings = get_npc_settings(obj)
        local base_freq = get_mcm_setting("base_detection_freq", 2000)
        
        mai_mob_session[id] = {
            added_restrictions = {},
            last_position = get_npc_pos(obj),
            custom_freq = base_freq,
            detect_timer = time_global() + base_freq,
            custom_miss_count_min = settings.chance_min,
            custom_miss_count_max = settings.chance_max,
            custom_miss_count_step = rd(settings.chance_min, settings.chance_max),
            custom_miss_count = 0,
            custom_detect_radius_min = settings.radius_min,
            custom_detect_radius_max = settings.radius_max,
            custom_detect_radius = rd(settings.radius_min, settings.radius_max),
            visual = obj:get_visual_name(),
            subscribe = false
        }
        
        mai_mob_session[id].custom_position_step = mai_mob_session[id].custom_detect_radius / 2
        mai_mob_session[id].visual_settings = get_npc_visual_settings(mai_mob_session[id].visual)
        
        npc_count = npc_count + 1
        mai_npc_anomalies_interaction(obj, false, true)
        
        dbg_subscribe("SUBSCRIBED [%s] - Count:%d Community:%s Rank:%s Radius:%.1f MissStep:%d",
            obj:name(), npc_count, community,
            ranks.get_se_obj_rank_name(obj) or "unknown",
            mai_mob_session[id].custom_detect_radius,
            mai_mob_session[id].custom_miss_count_step)
        
        if not is_debug_enabled() then
            printf("- SUB NPC [%d][%s]", npc_count, obj:name())
        end
    end
end

function mai_unsubscribe(obj, _type, text)
    if _type == "npc" or _type == "npc_serv" then
        local id = obj:id()
        
        if not mai_mob_session[id] then
            dbg_subscribe("NPC [%s] not subscribed", obj:name())
            return
        end
        
        -- Remove all added restrictions
        local t = mai_mob_session[id].added_restrictions
        if t then
            local del_rest = {}
            for k, _ in pairs(t) do
                if k then ti(del_rest, k) end
            end
            if tg(del_rest) > 0 then
                local rest_str = tc(del_rest, ",")
                dbg_restrict("Removing %d restrictions from [%s]", tg(del_rest), obj:name())
                obj:remove_restrictions("", rest_str)
            end
        end
        
        local rest_count = 0
        for _ in pairs(mai_mob_session[id].added_restrictions) do rest_count = rest_count + 1 end
        
        mai_mob_session[id] = nil
        mai_npc_anomalies_interaction(obj, false, false)
        npc_count = npc_count - 1
        if npc_count < 0 then npc_count = 0 end
        
        dbg_subscribe("UNSUBSCRIBED [%s] - Count:%d HadRestrictions:%d", obj:name(), npc_count, rest_count)
        
        if not is_debug_enabled() then
            printf("~ UNSUB NPC [%d][%s]", npc_count, obj:name())
        end
    end
end

function mai_subscribed(obj, _type)
    if _type == "npc" then
        return mai_mob_session[obj:id()] ~= nil
    end
    return false
end

function mai_evade(obj, _type)
    if _type == "npc" then
        mai_evade_npc(obj)
    end
end

function mai_evade_npc(npc)
    if not npc or not npc:alive() then return end
    if not mai_subscribed(npc, "npc") then return end
    
    local id = npc:id()
    local session = mai_mob_session[id]
    
    -- Check timer
    if session.detect_timer >= time_global() then return end
    session.detect_timer = time_global() + session.custom_freq
    
    if not session.subscribe then
        session.subscribe = true
        dbg_detect("NPC [%s] first detection cycle", npc:name())
    end
    
    -- Check movement
    local cur_position = get_npc_pos(npc)
    if session.last_position then
        local dist = session.last_position:distance_to(cur_position)
        if dist < session.custom_position_step then
            dbg_detect("NPC [%s] hasn't moved enough (%.2f < %.2f)", npc:name(), dist, session.custom_position_step)
            return
        end
    end
    session.last_position = cur_position
    
    -- Get nearby anomalies
    local nearby_anoms = mob_get_all_nearest_not_ignore_anoms(npc, session.custom_detect_radius)
    local restrictions = {}
    for _, v in pairs(nearby_anoms) do
        if v then ti(restrictions, v) end
    end
    
    local num_nearby = tg(restrictions)
    dbg_detect("NPC [%s] found %d anomalies within %.1fm", npc:name(), num_nearby, session.custom_detect_radius)
    
    if num_nearby > 0 then
        local add_rest = {}
        local del_rest = {}
        
        -- Find restrictions to remove
        for k, _ in pairs(session.added_restrictions) do
            local still_nearby = false
            for _, v in pairs(restrictions) do
                if v == k then still_nearby = true break end
            end
            if not still_nearby then
                ti(del_rest, k)
            end
        end
        
        -- Remove old restrictions
        if tg(del_rest) > 0 then
            for _, v in pairs(del_rest) do
                session.added_restrictions[v] = nil
            end
            local s = tc(del_rest, ",")
            dbg_restrict("NPC [%s] removing %d restrictions: %s", npc:name(), tg(del_rest), s)
            npc:remove_restrictions("", s)
        end
        
        -- Add new restrictions
        for _, v in pairs(restrictions) do
            if not session.added_restrictions[v] then
                if not should_mob_miss_this_anomaly(id) then
                    ti(add_rest, v)
                else
                    dbg_detect("NPC [%s] MISSED anomaly [%s]", npc:name(), v)
                end
            end
        end
        
        if tg(add_rest) > 0 then
            local s = tc(add_rest, ",")
            local max_len = get_mcm_setting("max_restrictions_length", 3072)
            
            if npc:in_restrictions():len() + 1 + s:len() < max_len then
                npc:add_restrictions("", s)
                dbg_restrict("NPC [%s] adding %d restrictions: %s", npc:name(), tg(add_rest), s)
                for _, v in ipairs(add_rest) do
                    session.added_restrictions[v] = true
                end
                
                if get_mcm_setting("debug_show_anomalies_on_map", false) then
                    _dbg_show_anoms()
                end
            else
                local factor = get_mcm_setting("radius_reduction_factor", 0.75)
                session.custom_detect_radius = session.custom_detect_radius * factor
                session.custom_freq = session.custom_freq * factor
                session.detect_timer = time_global() + 200
                dbg_restrict("NPC [%s] hit limit! Reducing radius to %.1f", npc:name(), session.custom_detect_radius)
            end
        end
    end
end

--------------------------------------------------------------------------------
-- Settings Functions
--------------------------------------------------------------------------------

function get_npc_settings(npc)
    local t = zz_allc0r3_mai_npc_settings.mai_npc_settings
    local community = npc:character_community()
    local rank = ranks.get_se_obj_rank_name(npc)
    
    if not t[community] then
        dbg_detect("Community [%s] not found, using [%s]", community, t.base_c)
        community = t.base_c
    end
    if not t[community][rank] then
        dbg_detect("Rank [%s] not found, using [%s]", rank, t.base_r)
        rank = t.base_r
    end
    
    return t[community][rank]
end

function get_npc_visual_settings(npc_visual)
    if mai_npc_settings_by_visual[npc_visual] then
        return mai_npc_settings_by_visual[npc_visual]
    end
    
    mai_npc_settings_by_visual[npc_visual] = {}
    
    if not mai_npc_settings_file:section_exist(npc_visual) then
        mai_npc_settings_by_visual[npc_visual].standard = true
        dbg_detect("Visual [%s] not in config, using standard", npc_visual)
    else
        local ignore_str = mai_npc_settings_file:r_string(npc_visual, "ignore_list")
        mai_npc_settings_by_visual[npc_visual].ignore = str_explode(ignore_str, ",")
        
        local damage_str = mai_npc_settings_file:r_string(npc_visual, "damage_list")
        mai_npc_settings_by_visual[npc_visual].damage = {}
        
        for _, v in pairs(str_explode(damage_str, ",")) do
            if v then
                local t = str_explode(v, "|")
                mai_npc_settings_by_visual[npc_visual].damage[t[1]] = tonumber(t[2])
                dbg_detect("Visual [%s] damage: %s -> %.2f", npc_visual, t[1], tonumber(t[2]))
            end
        end
        mai_npc_settings_by_visual[npc_visual].standard = false
    end
    
    return mai_npc_settings_by_visual[npc_visual]
end

function get_npc_dmg_mult(mob, anomaly)
    if not get_mcm_setting("enable_visual_damage_mult", true) then return 1.0 end
    
    local session = mai_mob_session[mob:id()]
    if not session or session.visual_settings.standard then return 1.0 end
    
    for k, v in pairs(session.visual_settings.damage) do
        if k and v and sf(anomaly:name(), k) then
            dbg_damage("NPC [%s] damage mult for [%s]: %.2f", mob:name(), anomaly:name(), v)
            return v
        end
    end
    return 1.0
end

function is_npc_ignore_anom(mob, anomaly)
    local session = mai_mob_session[mob:id()]
    if not session or session.visual_settings.standard then return false end
    
    for _, v in pairs(session.visual_settings.ignore) do
        if v and sf(anomaly:name(), v) then
            dbg_detect("NPC [%s] ignoring [%s] (armor)", mob:name(), anomaly:name())
            return true
        end
    end
    return false
end

--------------------------------------------------------------------------------
-- Check Functions
--------------------------------------------------------------------------------

function surge_started()
    return (surge_manager.is_loaded() and surge_manager.is_started()) or
           (psi_storm_manager.is_loaded() and psi_storm_manager.is_started())
end

function get_npc_pos(npc)
    return utils_obj.safe_bone_pos(npc, "bip01_spine") or npc:position():add(vector():set(0, 0.4, 0))
end

function is_always_skip_anomalies(anomaly)
    local t = zz_allc0r3_mai_anomalies_settings.mai_always_ignore_anom
    local name = anomaly:name()
    for i = 1, tg(t) do
        if name == t[i] or sf(name, t[i]) then return true end
    end
    return false
end

function is_task_npc(npc)
    local id = npc:id()
    for _, v in pairs(mai_quest_mob_stor) do
        if v == id then
            dbg_subscribe("NPC [%s] is active task giver", npc:name())
            return true
        end
    end
    return false
end

function is_ignore_npc(npc)
    local id = npc:id()
    local section = npc:section()
    local profile = npc:profile_name()
    
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[section] then
        dbg_subscribe("NPC [%s] ignored (section: %s)", npc:name(), section)
        return true
    end
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[profile] then
        dbg_subscribe("NPC [%s] ignored (profile: %s)", npc:name(), profile)
        return true
    end
    if get_object_story_id(id) then
        dbg_subscribe("NPC [%s] has story ID", npc:name())
        return true
    end
    if IsTrader(npc) then
        dbg_subscribe("NPC [%s] is trader", npc:name())
        return true
    end
    return false
end

function is_companion_npc(npc)
    return npc and npc:has_info("npcx_is_companion")
end

function should_mob_miss_this_anomaly(id)
    local session = mai_mob_session[id]
    if session then
        session.custom_miss_count = session.custom_miss_count + 1
        if session.custom_miss_count >= session.custom_miss_count_step then
            session.custom_miss_count = 0
            session.custom_miss_count_step = rd(session.custom_miss_count_min, session.custom_miss_count_max)
            dbg_detect("NPC ID [%d] will miss next anomaly (step: %d)", id, session.custom_miss_count_step)
            return true
        end
    end
    return false
end

function mob_get_all_nearest_not_ignore_anoms(mob, radius)
    local t = {}
    if not mob then return t end
    radius = radius or 30
    
    local mob_pos = mob:position()
    local fields = bind_anomaly_field.fields_by_names
    local checked, found = 0, 0
    
    for _, v in pairs(fields) do
        checked = checked + 1
        local anom = alife_object(v.object:id())
        if anom and not is_always_skip_anomalies(anom) and not is_npc_ignore_anom(mob, anom) then
            local dist = v.object:position():distance_to(mob_pos)
            if radius >= dist then
                ti(t, anom:name())
                found = found + 1
            end
        end
    end
    
    dbg_detect("Scanned %d fields, found %d anomalies for [%s]", checked, found, mob:name())
    return t
end

--------------------------------------------------------------------------------
-- Task Manager Integration
--------------------------------------------------------------------------------

function tm_give_task(task_giver_id, task_id)
    if not task_giver_id then return end
    
    local npc = level.object_by_id(task_giver_id)
    if npc then
        if is_ignore_npc(npc) or
           zz_allc0r3_mai_npc_settings.mai_always_damage_ignore_community[npc:character_community()] or
           zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[npc:character_community()] then
            dbg_log("TASK", "Task giver [%s] already ignored", npc:name())
            return
        end
        
        mai_quest_mob_stor[task_id] = task_giver_id
        dbg_log("TASK", "Tracking task giver [%s] for task [%s]", npc:name(), task_id)
        
        if mai_subscribed(npc, "npc") then
            dbg_log("TASK", "Unsubscribing task giver [%s]", npc:name())
            mai_unsubscribe(npc, "npc")
        end
    end
end

function tm_complete_task(task_id)
    if task_id and mai_quest_mob_stor[task_id] then
        dbg_log("TASK", "Task [%s] completed", task_id)
        mai_quest_mob_stor[task_id] = nil
    end
end

function tm_fail_task(task_id)
    if task_id and mai_quest_mob_stor[task_id] then
        dbg_log("TASK", "Task [%s] failed", task_id)
        mai_quest_mob_stor[task_id] = nil
    end
end

--------------------------------------------------------------------------------
-- Debug Display
--------------------------------------------------------------------------------

local show = false

function sim_object_level_name(s_obj)
    return alife():level_name(game_graph():vertex(s_obj.m_game_vertex_id):level_id())
end

function _dbg_show_anoms()
    if not is_debug_enabled() or not get_mcm_setting("debug_show_anomalies_on_map", false) then return end
    if show then return end
    
    local count = 0
    for i = 1, 65534 do
        local obj = alife():object(i)
        if obj and IsAnomaly(obj) then
            if sim_object_level_name(obj) == level.name() and not is_always_skip_anomalies(obj) then
                if level.map_has_object_spot(i, "anomaly_disabled") ~= 0 then
                    level.map_remove_object_spot(i, "anomaly_disabled")
                end
                level.map_add_object_spot_ser(i, "anomaly_disabled", "Name: "..obj:name().." \\nSection: "..obj:section_name())
                count = count + 1
            end
        end
    end
    dbg_log("MAP", "Added %d anomaly markers", count)
    show = true
end

--------------------------------------------------------------------------------
-- Batch Operations
--------------------------------------------------------------------------------

function on_option_change()
    update_mcm_cache()
    dbg_log("CONFIG", "MCM options updated - Enabled:%s Debug:%s", tostring(cached_mod_enabled), tostring(cached_debug_mode))
end

function mai_unsubscribe_all()
    local count = 0
    for k, _ in pairs(mai_mob_session) do
        local obj = level.object_by_id(k)
        if obj then
            mai_unsubscribe(obj, "npc")
            count = count + 1
        else
            dbg_log("WARN", "Stale entry [%d] removed", k)
            mai_mob_session[k] = nil
            npc_count = npc_count - 1
        end
    end
    dbg_log("BATCH", "Unsubscribed %d NPCs, total: %d", count, npc_count)
    printf("-[MAI] All NPCs unsubscribed [%d]", npc_count)
end

function mai_subscribe_all()
    if not db.OnlineStalkers then
        dbg_log("BATCH", "No OnlineStalkers available")
        return
    end
    
    local count = 0
    for _, v in ipairs(db.OnlineStalkers) do
        if v then
            local npc = level.object_by_id(v)
            if npc and npc:alive() then
                mai_subscribe(npc, "npc", nil, true)
                count = count + 1
            end
        end
    end
    dbg_log("BATCH", "Subscribed %d NPCs, total: %d", count, npc_count)
    printf("-[MAI] All NPCs subscribed [%d]", npc_count)
end

--------------------------------------------------------------------------------
-- Event Handlers
--------------------------------------------------------------------------------

function actor_on_interaction(a, b, c)
    if a == "anomalies" then
        if c == "emission_start" or c == "psi_storm_start" then
            dbg_log("EVENT", "Surge started [%s]", c)
            if zz_allc0r3_mai_callbacks.sleep_is_active == false then
                mai_unsubscribe_all()
            end
        elseif c == "emission_end" or c == "psi_storm_end" then
            dbg_log("EVENT", "Surge ended [%s]", c)
            if zz_allc0r3_mai_callbacks.sleep_is_active == false then
                mai_subscribe_all()
            end
            show = false
            _dbg_show_anoms()
        end
    end
end

function actor_on_sleep_new(sleep)
    if sleep then
        dbg_log("EVENT", "Player sleeping")
        mai_unsubscribe_all()
    else
        dbg_log("EVENT", "Player woke up")
        mai_subscribe_all()
    end
end

--------------------------------------------------------------------------------
-- Save/Load
--------------------------------------------------------------------------------

function load_state(mdata)
    mai_quest_mob_stor = mdata.AllC0r3_mai_quest_mob_stor or {}
    local count = 0
    for _ in pairs(mai_quest_mob_stor) do count = count + 1 end
    dbg_log("SAVE", "Loaded %d task givers", count)
end

function save_state(mdata)
    mdata.AllC0r3_mai_quest_mob_stor = mai_quest_mob_stor
    local count = 0
    for _ in pairs(mai_quest_mob_stor) do count = count + 1 end
    dbg_log("SAVE", "Saved %d task givers", count)
end

--------------------------------------------------------------------------------
-- Initialization
--------------------------------------------------------------------------------

function on_game_start()
    update_mcm_cache()
    
    RegisterScriptCallback("tm_give_task", tm_give_task)
    RegisterScriptCallback("tm_complete_task", tm_complete_task)
    RegisterScriptCallback("tm_fail_task", tm_fail_task)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("actor_on_interaction", actor_on_interaction)
    RegisterScriptCallback("actor_on_sleep_new", actor_on_sleep_new)
    
    dbg_log("INIT", "MAI v2.0 initialized - MCM:%s Debug:%s", tostring(ui_mcm ~= nil), tostring(cached_debug_mode))
    printf("-[MAI] Mutant/Anomaly Interaction v2.0 loaded (MCM: %s)", tostring(ui_mcm ~= nil))
end
