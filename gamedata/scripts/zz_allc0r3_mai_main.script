--[[
    MAI (Mutant/Anomaly Interaction) by Priler (original idea/mod by AllC0r3)
    Version: 2.4

    Features:
    - Lightweight anomaly cache (rebuilt only after surge/psy-storm)
    - Simple pathfinding restrictions (no per-NPC session tracking)
    - Damage roll based on rank + movement state
    - Effect radius system from Beef's NPCs Dies in Anomalies mod (configurable via MCM)
    - Arrival mod compatibility
    - anomaly_on_before_activate callback for efficient NPC protection (v2.3)
    - Experimental: Active flee system for stuck NPCs (v2.4)
    
    Design:
    - Cache anomalies once after surge, reuse until next surge
    - Single global update loop for all NPCs
    - No subscribe/unsubscribe system
    - Two-layer protection: anomaly_on_before_activate blocks protected NPCs,
      damage callback handles rank-based rolls for normal NPCs
--]]


-- ### Local aliases for performance

local sf = string.find
local ti = table.insert
local tc = table.concat
local rd = math.random


-- ### Module variables

-- Anomaly cache - rebuilt after each surge/psy-storm
local anomaly_cache = {}
local cache_valid = false
local cache_level = nil

-- Global update timer
local global_update_timer = 0
local UPDATE_INTERVAL = 2000 -- Check all NPCs every 2 seconds

-- Debug flag cache
local cached_debug_mode = false
local cached_verbose_debug = false
local cached_mod_enabled = true
local cached_show_debug_anomalies = false

-- Track last restriction add time per NPC to avoid spam
local npc_last_update = {}

-- Debug anomaly markers shown flag
local debug_anomalies_shown = false


-- ### MCM Integration

local function get_mcm_setting(key, default)
    if zz_allc0r3_mai_mcm then
        local getter = zz_allc0r3_mai_mcm["get_config"]
        if getter then
            local val = getter(key)
            if val ~= nil then return val end
        end
    end
    return default
end

local function is_mod_enabled() return cached_mod_enabled end
function is_debug_enabled() return cached_debug_mode end
local function is_verbose_debug() return cached_verbose_debug end
local function should_show_debug_anomalies() return cached_show_debug_anomalies end

local function update_mcm_cache()
    cached_mod_enabled = get_mcm_setting("mod_enabled", true)
    cached_debug_mode = get_mcm_setting("debug_mode", false)
    cached_verbose_debug = get_mcm_setting("verbose_debug", false)
    cached_show_debug_anomalies = get_mcm_setting("show_debug_anomalies", false)
end


-- ### Debug Logging

-- Basic debug log (restrictions, damage, deaths - important stuff)
local function dbg_log(category, format, ...)
    if not is_debug_enabled() then return end
    local msg = string.format(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end

-- Verbose debug log (update loop, cache, config - spammy stuff)
local function dbg_verbose(category, format, ...)
    if not is_verbose_debug() then return end
    local msg = string.format(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end


-- ### Arrival Mod Compatibility

local arrival_checked = false
local arrival_loaded = false

local function is_arrival_loaded()
    if not arrival_checked then
        arrival_loaded = arrival_zone_disable ~= nil and 
                        arrival_zone_disable.zd_spawn and
                        arrival_zone_disable.zd_spawn.zones_to_disable
        arrival_checked = true
    end
    return arrival_loaded
end

local function is_arrival_anomaly_active(anom_id, level_name)
    if not is_arrival_loaded() then return true end
    
    local zones_to_disable = arrival_zone_disable.zd_spawn.zones_to_disable
    if not zones_to_disable then return true end
    
    local level_zones = zones_to_disable[level_name]
    if not level_zones then return true end
    
    -- If anomaly ID is in the disable list, it's disabled
    if level_zones[anom_id] then
        return false
    end
    
    return true
end


-- ### Anomaly Cache System

local function is_always_skip_anomaly(anom_name)
    local t = zz_allc0r3_mai_anomalies_settings.mai_always_ignore_anom
    for i = 1, #t do
        if anom_name == t[i] or sf(anom_name, t[i]) then return true end
    end
    return false
end

local function rebuild_anomaly_cache()
    anomaly_cache = {}
    local level_name = level.name()
    cache_level = level_name
    
    local fields = bind_anomaly_field.fields_by_names
    if not fields then 
        dbg_verbose("CACHE", "No anomaly fields found")
        cache_valid = true
        return 
    end
    
    local count = 0
    local skipped = 0
    local disabled = 0
    local arrival_loaded_now = is_arrival_loaded()
    
    -- Get dynamic anomalies state table
    local dyn_anomalies = bind_anomaly_field.dyn_anomalies
    local dyn_anomalies_level = dyn_anomalies and dyn_anomalies[level_name]
    
    for _, v in pairs(fields) do
        local anom_obj = v.object
        if anom_obj then
            local anom_id = anom_obj:id()
            local se_obj = alife_object(anom_id)
            
            if se_obj then
                local anom_name = se_obj:name()
                
                -- Skip always-ignored anomalies
                if is_always_skip_anomaly(anom_name) then
                    skipped = skipped + 1
                else
                    local is_active = true
                    
                    -- Check Arrival mod
                    if arrival_loaded_now then
                        is_active = is_arrival_anomaly_active(anom_id, level_name)
                    end
                    
                    -- Check dynamic anomalies state (true = enabled, false = disabled)
                    if is_active and dyn_anomalies_level then
                        local dyn_state = dyn_anomalies_level[anom_id]
                        if dyn_state == false then
                            is_active = false
                            disabled = disabled + 1
                            dbg_verbose("CACHE", "Skipping disabled dynamic anomaly: %s", anom_name)
                        end
                    end
                    
                    if is_active then
                        -- Validate position before adding to cache
                        local pos = anom_obj:position()
                        if pos and pos.x and pos.y and pos.z then
                            -- Make anomaly a restrictor so AI pathfinding avoids it
                            -- restrictor_type 3 = "in" restrictor (NPCs can't enter)
                            if anom_obj.set_restrictor_type then
                                anom_obj:set_restrictor_type(3)
                            end
                            
                            ti(anomaly_cache, {
                                id = anom_id,
                                name = anom_name,
                                pos = pos,
                                section = se_obj:section_name()
                            })
                            count = count + 1
                        else
                            dbg_verbose("CACHE", "Skipping anomaly with invalid position: %s", anom_name)
                            skipped = skipped + 1
                        end
                    else
                        skipped = skipped + 1
                    end
                end
            end
        end
    end
    
    cache_valid = true
    dbg_verbose("CACHE", "Rebuilt anomaly cache: %d active, %d skipped, %d disabled (level: %s)", 
        count, skipped, disabled, level_name)
    dbg_log("CACHE", "Anomaly cache rebuilt: %d anomalies on %s", count, level_name)
end

local function invalidate_cache()
    cache_valid = false
    dbg_verbose("CACHE", "Cache invalidated")
end

local function ensure_cache()
    local current_level = level.name()
    if not cache_valid or cache_level ~= current_level then
        rebuild_anomaly_cache()
        -- Refresh debug markers if they were shown (delayed to avoid recursion)
        if cached_show_debug_anomalies then
            CreateTimeEvent("mai_debug_markers", "refresh", 0.5, function()
                if cached_show_debug_anomalies and cache_valid then
                    -- Don't call ensure_cache again, just update markers with current cache
                    local count = 0
                    for _, anom in ipairs(anomaly_cache) do
                        local id = anom.id
                        if level.map_has_object_spot(id, "anomaly_disabled") ~= 0 then
                            level.map_remove_object_spot(id, "anomaly_disabled")
                        end
                        local marker_text = string.format("MAI: %s\\n%s", anom.name, anom.section)
                        level.map_add_object_spot_ser(id, "anomaly_disabled", marker_text)
                        count = count + 1
                    end
                    debug_anomalies_shown = true
                    dbg_log("DEBUG", "Refreshed %d anomaly markers on map", count)
                end
                return true
            end)
        end
    end
end


-- ### NPC Checks

local function is_ignore_npc(npc)
    local id = npc:id()
    local section = npc:section()
    local profile = npc:profile_name()
    
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[section] then
        dbg_verbose("IGNORE", "NPC [%s] ignored by section [%s]", npc:name(), section)
        return true
    end
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[profile] then
        dbg_verbose("IGNORE", "NPC [%s] ignored by profile [%s]", npc:name(), profile)
        return true
    end
    if get_object_story_id(id) then
        dbg_verbose("IGNORE", "NPC [%s] ignored by story_id [%s]", npc:name(), get_object_story_id(id))
        return true
    end
    if IsTrader(npc) then
        dbg_verbose("IGNORE", "NPC [%s] ignored - is trader", npc:name())
        return true
    end
    return false
end

local function is_companion_npc(npc)
    if not npc then return false end
    return npc:has_info("npcx_is_companion")
end

-- Check if NPC is an escort/task target that should be protected
-- Simple check using story ID (quest-critical NPCs have story IDs)
local function is_task_target_npc(npc)
    if not npc then return false end
    
    -- Check story ID - story NPCs are quest-critical and should be protected
    local npc_id = npc:id()
    if get_object_story_id and get_object_story_id(npc_id) then
        return true
    end
    
    -- Check if NPC has escort infoportion
    if npc:has_info("npcx_beh_escort_target") then
        return true
    end
    
    return false
end

-- Check if NPC should have anomaly damage ENABLED at engine level
-- Returns false for NPCs that should NEVER take damage (callback won't fire)
-- Returns true for NPCs that MIGHT take damage (callback will fire, then we roll)
-- Returns: enabled (bool), reason (string)
-- Note: Caller must verify npc is valid, alive, and IsStalker before calling
local function should_enable_anomaly_damage(npc)
    -- Safety: never process the actor
    if npc:id() == 0 then return true, "actor" end
    
    local community = npc:character_community()
    
    -- Full ignore - no damage (greh)
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false, "full_ignore_community"
    end
    
    -- No damage communities - they evade but don't take damage (monolith)
    if zz_allc0r3_mai_npc_settings.mai_no_damage_community[community] then
        return false, "no_damage_community"
    end
    
    -- Important NPCs - no damage
    if is_ignore_npc(npc) then 
        return false, "ignore_npc"
    end
    
    -- Companions - no damage
    if is_companion_npc(npc) then 
        return false, "companion"
    end
    
    -- Task/escort targets - no damage
    if is_task_target_npc(npc) then
        return false, "task_target"
    end
    
    -- Everyone else can take damage (zombied, stalkers, etc.)
    -- The actual damage is determined by roll in should_npc_take_damage()
    return true, "normal"
end

-- Check if NPC should get pathfinding restrictions (try to avoid anomalies)
-- Returns false for NPCs that should walk into anomalies
-- Note: Caller must verify npc is valid, alive, and IsStalker before calling
local function should_add_restrictions(npc)
    local community = npc:character_community()
    
    -- Full ignore - no restrictions (greh)
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false
    end
    
    -- No evade communities - no restrictions, walk straight into anomalies (zombied)
    if zz_allc0r3_mai_npc_settings.mai_no_evade_community[community] then
        return false
    end
    
    -- Important NPCs - no restrictions (they're protected anyway)
    if is_ignore_npc(npc) then return false end
    
    -- Companions - no restrictions (they follow player, restrictions might interfere)
    if is_companion_npc(npc) then return false end
    
    -- Task targets - no restrictions (they need to follow player/path)
    if is_task_target_npc(npc) then return false end
    
    -- Everyone else gets restrictions (monolith, stalkers, etc.)
    return true
end

-- Configure NPC anomaly interaction based on community/status
local function configure_npc_anomaly_interaction(npc)
    if not npc or not npc:alive() then return end
    if not IsStalker(npc) then return end
    
    local should_damage, reason = should_enable_anomaly_damage(npc)
    npc:set_enable_anomalies_damage(should_damage)
    
    dbg_verbose("CONFIG", "NPC [%s] community [%s] damage=%s (%s)", 
        npc:name(), npc:character_community(), tostring(should_damage), reason)
end


-- ### Rank and Movement State

-- Cached rank settings (avoid recreating tables on every call)
local RANK_MCM_KEYS = {
    ["novice"] = "rank_novice_miss_chance",
    ["trainee"] = "rank_trainee_miss_chance",
    ["experienced"] = "rank_experienced_miss_chance",
    ["professional"] = "rank_professional_miss_chance",
    ["veteran"] = "rank_veteran_miss_chance",
    ["expert"] = "rank_expert_miss_chance",
    ["master"] = "rank_master_miss_chance",
    ["legend"] = "rank_legend_miss_chance"
}

local RANK_DEFAULTS = {
    ["novice"] = 100,
    ["trainee"] = 75,
    ["experienced"] = 50,
    ["professional"] = 25,
    ["veteran"] = 0,
    ["expert"] = 0,
    ["master"] = 0,
    ["legend"] = 0
}

function get_rank_miss_chance(npc)
    if not npc then return 50 end
    
    -- Use get_obj_rank_name for game objects (npc), not get_se_obj_rank_name (which is for server objects)
    local rank = ranks and ranks.get_obj_rank_name(npc) or nil
    if not rank then rank = "novice" end
    
    local setting_key = RANK_MCM_KEYS[rank] or "rank_novice_miss_chance"
    local default_val = RANK_DEFAULTS[rank] or 100
    
    return get_mcm_setting(setting_key, default_val)
end

local function get_movement_state_multiplier(npc)
    if not npc then return 1.0 end
    
    -- Combat check first (highest priority)
    if npc:best_enemy() then
        return get_mcm_setting("combat_miss_multiplier", 3.0)
    end
    
    local movement = npc:movement_type()
    
    if movement == move.stand then
        return get_mcm_setting("standing_miss_multiplier", 0.3)
    elseif movement == move.walk then
        return get_mcm_setting("walking_miss_multiplier", 0.6)
    elseif movement == move.run then
        return get_mcm_setting("running_miss_multiplier", 1.2)
    end
    
    return 1.0
end

local function get_movement_state_name(npc)
    if not npc then return "unknown" end
    if npc:best_enemy() then return "combat" end
    
    local movement = npc:movement_type()
    if movement == move.stand then return "standing"
    elseif movement == move.walk then return "walking"
    elseif movement == move.run then return "running"
    end
    return "unknown"
end


-- ### Pathfinding Restrictions

-- Track NPC positions to detect if they're stuck
local npc_positions = {}
local npc_stuck_count = {}
local npc_unstuck_until = {}  -- Track when NPC can receive restrictions again

local UNSTUCK_COOLDOWN = 20000  -- 20 seconds before NPC can get restrictions again after being unstuck


-- ### Active Flee System (Experimental)

-- Find the closest anomaly to the NPC
local function find_closest_anomaly(npc_pos)
    local closest = nil
    local closest_dist = 99999
    
    for _, anom in ipairs(anomaly_cache) do
        local dist = anom.pos:distance_to(npc_pos)
        if dist < closest_dist then
            closest_dist = dist
            closest = anom
        end
    end
    
    return closest, closest_dist
end

-- Find a safe position away from an anomaly using vanilla cover-finding
local function find_safe_position_from_anomaly(npc, anomaly_pos)
    local min_dist = get_mcm_setting("active_flee_min_distance", 15)
    local max_dist = get_mcm_setting("active_flee_max_distance", 40)
    
    -- Method 1: Use vanilla find_close_cover (treats anomaly as "enemy" to hide from)
    if utils_obj and utils_obj.find_close_cover then
        local cover_vid = utils_obj.find_close_cover(
            npc,                -- NPC object
            npc:position(),     -- Search from NPC's current position
            anomaly_pos,        -- "Hide" from the anomaly
            5,                  -- Initial cover search distance
            min_dist,           -- Minimum distance from anomaly
            max_dist            -- Maximum distance to search
        )
        
        if cover_vid then
            return cover_vid
        end
    end
    
    -- Method 2: Fallback - find vertex in opposite direction
    local npc_pos = npc:position()
    local away_dir = vector():set(
        npc_pos.x - anomaly_pos.x,
        0,
        npc_pos.z - anomaly_pos.z
    )
    away_dir:normalize()
    
    local base_vid = npc:level_vertex_id()
    
    -- Try to find vertex in that direction at increasing distances
    for dist = min_dist, max_dist, 5 do
        local test_vid = level.vertex_in_direction(base_vid, away_dir, dist)
        if test_vid and test_vid < 4294967295 and npc:accessible(test_vid) then
            -- Verify this position is actually far enough from anomaly
            local test_pos = level.vertex_position(test_vid)
            if test_pos:distance_to(anomaly_pos) >= min_dist then
                return test_vid
            end
        end
    end
    
    -- Method 3: Try different angles if direct path blocked
    for angle = 45, 315, 45 do
        local rotated_dir = vector_rotate_y(away_dir, angle)
        local test_vid = level.vertex_in_direction(base_vid, rotated_dir, min_dist)
        if test_vid and test_vid < 4294967295 and npc:accessible(test_vid) then
            return test_vid
        end
    end
    
    return nil  -- No safe position found
end

-- Make NPC actively flee from anomaly
local function flee_from_anomaly(npc, anomaly_pos, anomaly_name)
    local safe_vid = find_safe_position_from_anomaly(npc, anomaly_pos)
    
    if safe_vid then
        -- Set destination
        npc:set_dest_level_vertex_id(safe_vid)
        
        -- Make them run using state_mgr if available
        if state_mgr and state_mgr.set_state then
            pcall(function()
                state_mgr.set_state(npc, "sprint", nil, nil, nil, {fast_set = true})
            end)
        end
        
        dbg_log("FLEE", "NPC [%s] actively fleeing from [%s] to vertex %d", 
            npc:name(), anomaly_name, safe_vid)
        
        return true
    end
    
    dbg_log("FLEE", "NPC [%s] could not find safe position from [%s]", 
        npc:name(), anomaly_name)
    return false
end


-- ### Stuck Detection

local function get_nearby_anomalies(npc_pos, radius)
    local result = {}
    for _, anom in ipairs(anomaly_cache) do
        local dist = anom.pos:distance_to(npc_pos)
        if dist <= radius then
            ti(result, anom.name)
        end
    end
    return result
end

-- Check if NPC is stuck (hasn't moved significantly)
local function check_npc_stuck(npc, current_pos)
    local id = npc:id()
    local last_pos = npc_positions[id]
    
    if not last_pos then
        npc_positions[id] = current_pos
        npc_stuck_count[id] = 0
        return false
    end
    
    local distance_moved = last_pos:distance_to(current_pos)
    npc_positions[id] = current_pos
    
    -- If NPC moved less than 0.5 meters, increment stuck counter
    if distance_moved < 0.5 then
        npc_stuck_count[id] = (npc_stuck_count[id] or 0) + 1
    else
        npc_stuck_count[id] = 0
    end
    
    -- Consider stuck after 5 consecutive checks with no movement (10 seconds)
    return npc_stuck_count[id] >= 5
end

-- Clear restrictions for NPC
local function clear_npc_restrictions(npc)
    if not npc then return end
    
    local current_restrictions = npc:in_restrictions() or ""
    if current_restrictions ~= "" then
        pcall(function()
            npc:remove_restrictions("", current_restrictions)
        end)
        dbg_log("STUCK", "Cleared restrictions for stuck NPC [%s]", npc:name())
    end
    
    -- Reset stuck counter
    local id = npc:id()
    npc_stuck_count[id] = 0
end

local function update_npc_restrictions(npc, detection_radius)
    if not should_add_restrictions(npc) then return end
    
    local id = npc:id()
    local current_time = time_global()
    
    -- Throttle per-NPC updates
    if npc_last_update[id] and current_time - npc_last_update[id] < 1000 then
        return
    end
    npc_last_update[id] = current_time
    
    local npc_pos = npc:position()
    local radius = detection_radius or get_mcm_setting("base_detection_radius", 30)
    local nearby = get_nearby_anomalies(npc_pos, radius)
    
    -- No nearby anomalies - reset tracking
    if #nearby == 0 then
        npc_stuck_count[id] = 0
        npc_positions[id] = nil
        npc_unstuck_until[id] = nil
        return
    end
    
    -- NPC is near anomalies - check if still in unstuck cooldown
    if npc_unstuck_until[id] and current_time < npc_unstuck_until[id] then
        -- Still in cooldown, don't add restrictions
        return
    end
    
    -- Cooldown expired, clear it
    npc_unstuck_until[id] = nil
    
    -- Check if NPC is stuck
    if check_npc_stuck(npc, npc_pos) then
        -- Check if active flee is enabled
        local active_flee_enabled = get_mcm_setting("active_flee_enabled", false)
        
        if active_flee_enabled then
            -- Find closest anomaly and flee from it
            local closest_anom, closest_dist = find_closest_anomaly(npc_pos)
            if closest_anom then
                dbg_log("STUCK", "NPC [%s] stuck near [%s] (%.1fm), attempting active flee", 
                    npc:name(), closest_anom.name, closest_dist)
                
                -- Clear restrictions first so NPC can move freely
                clear_npc_restrictions(npc)
                
                -- Try to flee
                if flee_from_anomaly(npc, closest_anom.pos, closest_anom.name) then
                    dbg_log("STUCK", "NPC [%s] active flee successful", npc:name())
                else
                    dbg_log("STUCK", "NPC [%s] active flee failed, using fallback", npc:name())
                end
            else
                -- No anomaly found, just clear restrictions
                clear_npc_restrictions(npc)
            end
        else
            -- Original behavior: just clear restrictions
            clear_npc_restrictions(npc)
            dbg_log("STUCK", "NPC [%s] unstuck (restrictions cleared)", npc:name())
        end
        
        -- Set cooldown - NPC won't get new restrictions for 20 seconds
        npc_unstuck_until[id] = current_time + UNSTUCK_COOLDOWN
        return
    end
    
    -- Get current restrictions
    local current_restrictions = npc:in_restrictions() or ""
    local max_len = get_mcm_setting("max_restrictions_length", 2048)
    
    -- If restrictions are getting too long, clear some old ones
    if current_restrictions:len() > max_len * 0.8 then
        dbg_log("RESTRICT", "NPC [%s] restrictions near limit (%d), clearing", 
            npc:name(), current_restrictions:len())
        clear_npc_restrictions(npc)
        current_restrictions = ""
    end
    
    -- Find anomalies not already in restrictions
    local to_add = {}
    for _, anom_name in ipairs(nearby) do
        if not sf(current_restrictions, anom_name) then
            -- Roll for miss based on rank
            local miss_chance = get_rank_miss_chance(npc)
            local state_mult = get_movement_state_multiplier(npc)
            local final_chance = math.floor(miss_chance * state_mult)
            
            if final_chance <= 0 or rd(1, 100) > final_chance then
                -- NPC detects this anomaly (roll > chance means success)
                ti(to_add, anom_name)
            else
                dbg_log("DETECT", "NPC [%s] missed anomaly [%s] (roll <= %d%%)", 
                    npc:name(), anom_name, final_chance)
            end
        end
    end
    
    -- Add new restrictions
    if #to_add > 0 then
        local add_str = tc(to_add, ",")
        if current_restrictions:len() + add_str:len() + 1 < max_len then
            npc:add_restrictions("", add_str)
            dbg_log("RESTRICT", "NPC [%s] added %d restrictions: %s", 
                npc:name(), #to_add, add_str)
        end
    end
end


-- ### Damage System

function should_npc_take_damage(npc, anomaly)
    if not npc or not anomaly then return true end
    
    -- Note: Community checks (greh, monolith), companion checks, and important NPC checks
    -- are now handled at engine level via set_enable_anomalies_damage(false)
    -- This callback only fires for NPCs that CAN take damage
    
    -- Always skip during surge
    if surge_started() then
        dbg_log("DAMAGE", "Surge active, blocking damage to [%s]", npc:name())
        return false
    end
    
    -- Check if anomaly should be skipped
    local anom_name = anomaly:name()
    if is_always_skip_anomaly(anom_name) then
        return false
    end
    
    -- Get rank miss chance once (used multiple times below)
    local miss_chance = get_rank_miss_chance(npc)
    
    -- Immunity for 0% miss chance (veterans+)
    if get_mcm_setting("immune_zero_miss_chance", true) then
        if miss_chance == 0 then
            dbg_log("DAMAGE", "NPC [%s] immune (0%% miss chance), blocking damage", npc:name())
            return false
        end
    end
    
    -- Roll for damage based on rank + state
    local state_mult = get_movement_state_multiplier(npc)
    local damage_chance = math.floor(miss_chance * state_mult)
    
    -- Higher miss_chance = more likely to take damage
    -- Novice running in combat: 100 * 3.0 = 300% (capped at 100) = always takes damage
    -- Veteran standing: 0 * 0.3 = 0% = never takes damage
    
    if damage_chance > 100 then damage_chance = 100 end
    
    local roll = rd(1, 100)
    local takes_damage = roll <= damage_chance
    
    local state = get_movement_state_name(npc)
    local rank = ranks and ranks.get_obj_rank_name(npc) or "unknown"
    
    if takes_damage then
        dbg_log("DAMAGE", "NPC [%s] (rank: %s, state: %s) HIT by [%s] (roll: %d <= %d%%)", 
            npc:name(), rank, state, anom_name, roll, damage_chance)
    else
        dbg_log("DAMAGE", "NPC [%s] (rank: %s, state: %s) AVOIDED [%s] (roll: %d > %d%%)", 
            npc:name(), rank, state, anom_name, roll, damage_chance)
    end
    
    return takes_damage
end


-- ### Anomaly Before Activate Callback (First Line of Defense)

-- This callback is called by the engine BEFORE an anomaly tries to affect an object
-- Returning false in flags.ret_value makes the anomaly completely ignore the object
-- This is more efficient than blocking damage in npc_on_before_hit because it
-- prevents the anomaly from even attempting to process the object
local function on_anomaly_before_activate(zone, obj, flags)
    -- Only process if mod is enabled
    if not is_mod_enabled() then return end
    
    -- Skip if no object
    if not obj then return end
    
    -- IMPORTANT: Skip the player! We only want to affect NPCs
    if obj:id() == 0 then return end  -- Actor always has id 0
    
    -- Only process stalkers (vanilla already handles dead NPCs)
    if not IsStalker(obj) then return end
    if not obj:alive() then return end
    
    -- Skip during surge (anomalies behave differently)
    if surge_started() then return end
    
    -- Check if this NPC should be protected from anomaly damage
    local should_damage, reason = should_enable_anomaly_damage(obj)
    
    if not should_damage then
        -- Block the anomaly from affecting this NPC entirely
        flags.ret_value = false
        dbg_verbose("BLOCK", "Anomaly [%s] blocked from affecting [%s] (%s)", 
            zone:name(), obj:name(), reason)
    end
    
    -- Note: NPCs that CAN take damage will still go through should_npc_take_damage()
    -- via the npc_on_before_hit callback for the actual damage roll
end


-- ### Armor Protection System

-- Map anomaly patterns to protection stats (for pattern matching)
local ANOMALY_PROTECTION_PATTERNS = {
    -- Electric anomalies
    { pattern = "electra",      protection = "shock_protection" },
    { pattern = "electric",     protection = "shock_protection" },
    { pattern = "tesla",        protection = "shock_protection" },
    { pattern = "static",       protection = "shock_protection" },
    
    -- Thermal/Fire anomalies
    { pattern = "burner",       protection = "burn_protection" },
    { pattern = "thermal",      protection = "burn_protection" },
    { pattern = "fire",         protection = "burn_protection" },
    { pattern = "inferno",      protection = "burn_protection" },
    { pattern = "zharka",       protection = "burn_protection" },
    
    -- Chemical/Acid anomalies
    { pattern = "acidic",       protection = "chemical_burn_protection" },
    { pattern = "chemical",     protection = "chemical_burn_protection" },
    { pattern = "gas",          protection = "chemical_burn_protection" },
    { pattern = "fruit_punch",  protection = "chemical_burn_protection" },
    
    -- Gravity anomalies
    { pattern = "gravitational", protection = "strike_protection" },
    { pattern = "springboard",   protection = "strike_protection" },
    { pattern = "vortex",        protection = "strike_protection" },
    { pattern = "whirligig",     protection = "strike_protection" },
    { pattern = "galantine",     protection = "strike_protection" },
    { pattern = "tramplin",      protection = "strike_protection" },
    
    -- Radiation anomalies
    { pattern = "radioactive",  protection = "radiation_protection" },
    { pattern = "radiation",    protection = "radiation_protection" },
    
    -- Psy anomalies
    { pattern = "psy",          protection = "telepatic_protection" },
    { pattern = "brain",        protection = "telepatic_protection" },
    { pattern = "telepatic",    protection = "telepatic_protection" },
}

-- Cache for already-resolved anomaly sections (O(1) lookup after first hit)
local anomaly_protection_cache = {}

-- Get protection type for an anomaly
local function get_anomaly_protection_type(anomaly_section)
    if not anomaly_section then return nil end
    
    -- Check cache first
    local cached = anomaly_protection_cache[anomaly_section]
    if cached ~= nil then
        return cached ~= false and cached or nil
    end
    
    -- Pattern match and cache result
    local section_lower = anomaly_section:lower()
    for _, mapping in ipairs(ANOMALY_PROTECTION_PATTERNS) do
        if sf(section_lower, mapping.pattern) then
            anomaly_protection_cache[anomaly_section] = mapping.protection
            return mapping.protection
        end
    end
    
    -- Cache negative result too (false means "no match found")
    anomaly_protection_cache[anomaly_section] = false
    return nil
end

-- Get NPC's outfit protection value
local function get_npc_outfit_protection(npc, protection_type)
    if not npc or not protection_type then return 0 end
    
    -- Try to get outfit from slot 7 (outfit slot)
    local outfit = npc:item_in_slot(7)
    if not outfit then 
        dbg_verbose("ARMOR", "NPC [%s] has no outfit", npc:name())
        return 0 
    end
    
    local outfit_section = outfit:section()
    if not outfit_section then return 0 end
    
    -- Read protection value from outfit config
    local protection = SYS_GetParam(2, outfit_section, protection_type, 0)
    
    dbg_verbose("ARMOR", "NPC [%s] outfit [%s] %s = %.3f", 
        npc:name(), outfit_section, protection_type, protection)
    
    return protection or 0
end

function get_npc_dmg_mult(npc, anomaly)
    if not npc then return 1.0 end
    
    -- Check if armor damage multipliers enabled
    if not get_mcm_setting("enable_armor_damage_mult", true) then
        return 1.0
    end
    
    if not anomaly then return 1.0 end
    
    local anomaly_section = anomaly:section()
    if not anomaly_section then return 1.0 end
    
    -- Get protection type for this anomaly
    local protection_type = get_anomaly_protection_type(anomaly_section)
    if not protection_type then
        dbg_verbose("ARMOR", "Unknown anomaly type [%s], using full damage", anomaly_section)
        return 1.0
    end
    
    -- Get NPC's protection value
    local protection = get_npc_outfit_protection(npc, protection_type)
    
    -- Convert protection to damage multiplier
    -- protection = 0.0 → mult = 1.0 (full damage)
    -- protection = 0.5 → mult = 0.5 (half damage)
    -- protection = 1.0 → mult = 0.0 (no damage)
    -- protection > 1.0 → mult = negative (healing? cap at 0)
    local damage_mult = math.max(0, 1.0 - protection)
    
    dbg_verbose("ARMOR", "Anomaly [%s] → %s → protection %.2f → damage mult %.2f",
        anomaly_section, protection_type, protection, damage_mult)
    
    return damage_mult
end


-- ### Surge Detection

function surge_started()
    return (surge_manager and surge_manager.is_loaded() and surge_manager.is_started()) or
           (psi_storm_manager and psi_storm_manager.is_loaded() and psi_storm_manager.is_started())
end


-- ### Map Marker Cleanup (for old versions)

local function cleanup_old_map_markers()
    local count = 0
    for i = 1, 65534 do
        if level.map_has_object_spot(i, "anomaly_disabled") ~= 0 then
            level.map_remove_object_spot(i, "anomaly_disabled")
            count = count + 1
        end
    end
    
    if count > 0 then
        dbg_log("CLEANUP", "Cleaned up %d old map markers", count)
    end
    
    return count
end

-- Called when MCM option changes
local function on_option_change()
    local old_show_debug = cached_show_debug_anomalies
    update_mcm_cache()
    
    -- Check if cleanup was requested
    if get_mcm_setting("cleanup_map_markers", false) then
        cleanup_old_map_markers()
    end
    
    -- Check if debug anomaly display changed
    if cached_show_debug_anomalies ~= old_show_debug then
        if cached_show_debug_anomalies then
            show_debug_anomaly_markers()
        else
            hide_debug_anomaly_markers()
        end
    end
end


-- ### Debug Anomaly Map Markers (Issue 2 debugging)

-- Show all cached anomalies on the map for debugging
function show_debug_anomaly_markers()
    if not db.actor then return end
    
    -- First ensure cache is built
    ensure_cache()
    
    local count = 0
    for _, anom in ipairs(anomaly_cache) do
        local id = anom.id
        -- Remove existing marker if any
        if level.map_has_object_spot(id, "anomaly_disabled") ~= 0 then
            level.map_remove_object_spot(id, "anomaly_disabled")
        end
        -- Add marker with anomaly info
        local marker_text = string.format("MAI: %s\\n%s", anom.name, anom.section)
        level.map_add_object_spot_ser(id, "anomaly_disabled", marker_text)
        count = count + 1
    end
    
    debug_anomalies_shown = true
    dbg_log("DEBUG", "Showing %d anomaly markers on map", count)
end

-- Hide all debug anomaly markers
function hide_debug_anomaly_markers()
    local count = 0
    for i = 1, 65534 do
        if level.map_has_object_spot(i, "anomaly_disabled") ~= 0 then
            level.map_remove_object_spot(i, "anomaly_disabled")
            count = count + 1
        end
    end
    
    debug_anomalies_shown = false
    if count > 0 then
        dbg_log("DEBUG", "Removed %d anomaly markers from map", count)
    end
end


-- ### Global Update Loop

-- Check if current level should be ignored
local function is_ignore_level()
    local current_level = level.name()
    return zz_allc0r3_mai_location_settings and 
           zz_allc0r3_mai_location_settings.mai_always_ignore_levels and
           zz_allc0r3_mai_location_settings.mai_always_ignore_levels[current_level]
end

local function on_actor_update()
    if not is_mod_enabled() then 
        dbg_verbose("UPDATE", "Mod disabled, skipping")
        return 
    end
    if surge_started() then 
        dbg_verbose("UPDATE", "Surge active, skipping")
        return 
    end
    
    -- Check if db.actor is valid
    if not db.actor then 
        dbg_verbose("UPDATE", "No db.actor, skipping")
        return 
    end
    
    -- Skip ignored levels (underground labs, etc.)
    if is_ignore_level() then 
        dbg_verbose("UPDATE", "Level ignored: %s", level.name())
        return 
    end
    
    local current_time = time_global()
    if current_time < global_update_timer then return end
    
    global_update_timer = current_time + UPDATE_INTERVAL
    
    -- Ensure cache is valid
    ensure_cache()
    
    -- Cache MCM settings for this update cycle
    local effect_radius = get_mcm_setting("effect_radius", 300)
    local restrictions_ignore_radius = get_mcm_setting("restrictions_ignore_radius", true)
    local detection_radius = get_mcm_setting("base_detection_radius", 30)
    local actor_pos = db.actor:position()
    
    -- Count NPCs for debug
    local npc_count = 0
    local processed_count = 0
    
    -- Update all online stalkers
    for id, npc in pairs(db.OnlineStalkers) do
        npc_count = npc_count + 1
        -- some mods store just the id here
        if type(npc) == "number" then
            npc = level.object_by_id(npc)
        end

        -- Skip anything that is still not a valid game object
        if npc and npc.alive and npc:alive() and IsStalker(npc) then
            local npc_pos = npc:position()
            local distance = npc_pos:distance_to(actor_pos)
            local within_radius = distance <= effect_radius
            
            -- Damage: configure based on community only within radius
            -- Outside radius: always protect NPC from damage
            if within_radius then
                configure_npc_anomaly_interaction(npc)
            else
                npc:set_enable_anomalies_damage(false)
            end
            
            -- Restrictions: apply within radius, or everywhere if setting enabled
            if within_radius or restrictions_ignore_radius then
                update_npc_restrictions(npc, detection_radius)
            end
            
            processed_count = processed_count + 1
        end
    end
    
    -- Log once per update cycle if we processed NPCs
    if processed_count > 0 then
        dbg_verbose("UPDATE", "Processed %d/%d NPCs (cache: %d anomalies)", 
            processed_count, npc_count, #anomaly_cache)
    end
end


-- ### Callbacks

-- Delay cache rebuild to allow Arrival mod to finish respawning anomalies
-- Arrival uses: 0.5s delay for cleanup + 0.3s delay for spawn + queue processing

local function schedule_cache_rebuild(reason)
    local delay = get_mcm_setting("cache_rebuild_delay", 2.5)
    dbg_verbose("EVENT", "%s, scheduling cache rebuild in %.1fs", reason, delay)
    
    -- Cancel any pending rebuild
    RemoveTimeEvent("mai_cache_rebuild", "mai_cache_rebuild")
    
    -- If delay is 0, rebuild immediately
    if delay <= 0 then
        invalidate_cache()
        return
    end
    
    -- Schedule new rebuild with delay
    CreateTimeEvent("mai_cache_rebuild", "mai_cache_rebuild", delay, function()
        dbg_verbose("EVENT", "Executing delayed cache rebuild")
        invalidate_cache()
        return true
    end)
end

local function on_surge_end()
    schedule_cache_rebuild("Surge ended")
end

local function on_psy_storm_end()
    schedule_cache_rebuild("Psy-storm ended")
end

local function on_game_load()
    dbg_verbose("EVENT", "Game loaded, rebuilding cache")
    
    -- Enable anomaly damage for AI globally at engine level
    exec_console_cmd("ai_die_in_anomaly 1")
    dbg_verbose("EVENT", "Enabled ai_die_in_anomaly 1")
    
    invalidate_cache()
    npc_last_update = {} -- Clear throttle tracking
    npc_positions = {}   -- Clear position tracking
    npc_stuck_count = {} -- Clear stuck counters
    npc_unstuck_until = {} -- Clear unstuck cooldowns
end

local function on_level_changed()
    dbg_verbose("EVENT", "Level changed, invalidating cache")
    invalidate_cache()
    npc_last_update = {}
    npc_positions = {}
    npc_stuck_count = {}
    npc_unstuck_until = {}
end

-- Cleanup when NPC goes offline
local function on_npc_net_destroy(npc)
    local id
    if type(npc) == "number" then
        id = npc
    else
        id = npc:id()
        -- Try to remove restrictions before NPC goes offline
        if npc and npc.remove_restrictions then
            pcall(function()
                npc:remove_restrictions("", npc:in_restrictions() or "")
            end)
        end
    end
    npc_last_update[id] = nil
    npc_positions[id] = nil
    npc_stuck_count[id] = nil
    npc_unstuck_until[id] = nil
end

-- Configure NPC when it spawns online
local function on_npc_net_spawn(npc)
    if not is_mod_enabled() then return end
    if not npc then return end
    if not IsStalker(npc) then return end
    if not npc:alive() then return end
    
    -- Skip ignored levels (check once, same result as update loop will get)
    if is_ignore_level() then return end
    
    -- Skip if no anomalies cached on this level
    if #anomaly_cache == 0 and cache_valid then return end
    
    -- Configure damage settings immediately
    configure_npc_anomaly_interaction(npc)
    
    dbg_verbose("SPAWN", "NPC [%s] spawned, configured anomaly interaction", npc:name())
end


-- ### Initialization

function on_game_start()
    update_mcm_cache()
    
    -- Core callbacks
    RegisterScriptCallback("actor_on_update", on_actor_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("npc_on_net_destroy", on_npc_net_destroy)
    RegisterScriptCallback("npc_on_net_spawn", on_npc_net_spawn)
    
    -- Anomaly protection callback (first line of defense - blocks anomaly activation)
    RegisterScriptCallback("anomaly_on_before_activate", on_anomaly_before_activate)
    
    -- Cache invalidation callbacks
    RegisterScriptCallback("surge_manager_end_surge", on_surge_end)
    RegisterScriptCallback("psi_storm_manager_end_storm", on_psy_storm_end)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_first_update", on_game_load)
    RegisterScriptCallback("actor_on_level_changed", on_level_changed)
    
    local arrival_status = is_arrival_loaded() and "detected" or "not detected"
    dbg_log("INIT", "MAI v2.4 loaded - mod_enabled=%s, debug=%s, Arrival: %s", 
        tostring(cached_mod_enabled), tostring(cached_debug_mode), arrival_status)
end
