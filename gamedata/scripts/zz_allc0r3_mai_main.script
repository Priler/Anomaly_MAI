--[[
    MAI (Mutant/Anomaly Interaction) by Priler (original idea/mod by AllC0r3)
    Version: 2.1

    Features:
    - Lightweight anomaly cache (rebuilt only after surge/psy-storm)
    - Simple pathfinding restrictions (no per-NPC session tracking)
    - Damage roll based on rank + movement state
    - Effect radius system from Beef's NPCs Dies in Anomalies mod (configurable via MCM)
    - Arrival mod compatibility
    
    Design:
    - Cache anomalies once after surge, reuse until next surge
    - Single global update loop for all NPCs
    - No subscribe/unsubscribe system
    - Damage callback decides if NPC should take damage
--]]



--------------------------------------------------------------------------------
-- Local aliases for performance
--------------------------------------------------------------------------------

local sf = string.find
local ti = table.insert
local tc = table.concat
local rd = math.random

--------------------------------------------------------------------------------
-- Module variables
--------------------------------------------------------------------------------

-- Anomaly cache - rebuilt after each surge/psy-storm
local anomaly_cache = {}
local cache_valid = false
local cache_level = nil

-- Global update timer
local global_update_timer = 0
local UPDATE_INTERVAL = 2000 -- Check all NPCs every 2 seconds

-- Debug flag cache
local cached_debug_mode = false
local cached_verbose_debug = false
local cached_mod_enabled = true

-- Track last restriction add time per NPC to avoid spam
local npc_last_update = {}

--------------------------------------------------------------------------------
-- MCM Integration
--------------------------------------------------------------------------------

local function get_mcm_setting(key, default)
    if zz_allc0r3_mai_mcm then
        local getter = zz_allc0r3_mai_mcm["get_config"]
        if getter then
            local val = getter(key)
            if val ~= nil then return val end
        end
    end
    return default
end

local function is_mod_enabled() return cached_mod_enabled end
function is_debug_enabled() return cached_debug_mode end
local function is_verbose_debug() return cached_verbose_debug end

local function update_mcm_cache()
    cached_mod_enabled = get_mcm_setting("mod_enabled", true)
    cached_debug_mode = get_mcm_setting("debug_mode", false)
    cached_verbose_debug = get_mcm_setting("verbose_debug", false)
end

--------------------------------------------------------------------------------
-- Debug Logging
--------------------------------------------------------------------------------

-- Basic debug log (restrictions, damage, deaths - important stuff)
local function dbg_log(category, format, ...)
    if not is_debug_enabled() then return end
    local msg = string.format(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end

-- Verbose debug log (update loop, cache, config - spammy stuff)
local function dbg_verbose(category, format, ...)
    if not is_verbose_debug() then return end
    local msg = string.format(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end

--------------------------------------------------------------------------------
-- Arrival Mod Compatibility
--------------------------------------------------------------------------------

local arrival_checked = false
local arrival_loaded = false

local function is_arrival_loaded()
    if not arrival_checked then
        arrival_loaded = arrival_zone_disable ~= nil and 
                        arrival_zone_disable.zd_spawn and
                        arrival_zone_disable.zd_spawn.zones_to_disable
        arrival_checked = true
    end
    return arrival_loaded
end

local function is_arrival_anomaly_active(anom_id, level_name)
    if not is_arrival_loaded() then return true end
    
    local zones_to_disable = arrival_zone_disable.zd_spawn.zones_to_disable
    if not zones_to_disable then return true end
    
    local level_zones = zones_to_disable[level_name]
    if not level_zones then return true end
    
    -- If anomaly ID is in the disable list, it's disabled
    if level_zones[anom_id] then
        return false
    end
    
    return true
end

--------------------------------------------------------------------------------
-- Anomaly Cache System
--------------------------------------------------------------------------------

local function is_always_skip_anomaly(anom_name)
    local t = zz_allc0r3_mai_anomalies_settings.mai_always_ignore_anom
    for i = 1, #t do
        if anom_name == t[i] or sf(anom_name, t[i]) then return true end
    end
    return false
end

local function rebuild_anomaly_cache()
    anomaly_cache = {}
    local level_name = level.name()
    cache_level = level_name
    
    local fields = bind_anomaly_field.fields_by_names
    if not fields then 
        dbg_verbose("CACHE", "No anomaly fields found")
        cache_valid = true
        return 
    end
    
    local count = 0
    local skipped = 0
    local arrival_loaded_now = is_arrival_loaded()
    
    for _, v in pairs(fields) do
        local anom_obj = v.object
        if anom_obj then
            local anom_id = anom_obj:id()
            local se_obj = alife_object(anom_id)
            
            if se_obj then
                local anom_name = se_obj:name()
                
                -- Skip always-ignored anomalies
                if is_always_skip_anomaly(anom_name) then
                    skipped = skipped + 1
                else
                    -- Check Arrival mod
                    local is_active = true
                    if arrival_loaded_now then
                        is_active = is_arrival_anomaly_active(anom_id, level_name)
                    end
                    
                    if is_active then
                        ti(anomaly_cache, {
                            id = anom_id,
                            name = anom_name,
                            pos = anom_obj:position(),
                            section = se_obj:section_name()
                        })
                        count = count + 1
                    else
                        skipped = skipped + 1
                    end
                end
            end
        end
    end
    
    cache_valid = true
    dbg_verbose("CACHE", "Rebuilt anomaly cache: %d anomalies, %d skipped (level: %s)", count, skipped, level_name)
    printf("[MAI] Anomaly cache rebuilt: %d anomalies on %s", count, level_name)
end

local function invalidate_cache()
    cache_valid = false
    dbg_verbose("CACHE", "Cache invalidated")
end

local function ensure_cache()
    local current_level = level.name()
    if not cache_valid or cache_level ~= current_level then
        rebuild_anomaly_cache()
    end
end

--------------------------------------------------------------------------------
-- NPC Checks
--------------------------------------------------------------------------------

local function is_ignore_npc(npc)
    local id = npc:id()
    local section = npc:section()
    local profile = npc:profile_name()
    
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[section] then
        dbg_verbose("IGNORE", "NPC [%s] ignored by section [%s]", npc:name(), section)
        return true
    end
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[profile] then
        dbg_verbose("IGNORE", "NPC [%s] ignored by profile [%s]", npc:name(), profile)
        return true
    end
    if get_object_story_id(id) then
        dbg_verbose("IGNORE", "NPC [%s] ignored by story_id [%s]", npc:name(), get_object_story_id(id))
        return true
    end
    if IsTrader(npc) then
        dbg_verbose("IGNORE", "NPC [%s] ignored - is trader", npc:name())
        return true
    end
    return false
end

local function is_companion_npc(npc)
    if not npc then return false end
    
    -- Method 1: Standard companion info portion
    local ok, has_info = pcall(function() return npc:has_info("npcx_is_companion") end)
    if ok and has_info then
        return true
    end
    
    -- Method 2: Check axr_companions module directly
    local ok2, result = pcall(function()
        if axr_companions and axr_companions.companion_squads then
            local npc_id = npc:id()
            for squad_id, _ in pairs(axr_companions.companion_squads) do
                local squad = squad_id and alife_object(squad_id)
                if squad then
                    for member in squad:squad_members() do
                        if member and member.id == npc_id then
                            return true
                        end
                    end
                end
            end
        end
        return false
    end)
    if ok2 and result then return true end
    
    return false
end

-- Check if NPC is an escort/task target that should be protected
local function is_task_target_npc(npc)
    if not npc then return false end
    
    local npc_id = npc:id()
    
    -- Check if NPC has task-related infoportions
    -- These are given to NPCs that are quest targets (escort, rescue, etc.)
    local has_escort_info = pcall(function() return npc:has_info("npcx_beh_escort_target") end)
    if has_escort_info and npc:has_info("npcx_beh_escort_target") then
        return true
    end
    
    -- Check task manager for active escort/delivery tasks involving this NPC
    local ok, result = pcall(function()
        if task_manager and task_manager.get_task_manager then
            local tm = task_manager.get_task_manager()
            if tm and tm.task_info then
                for task_id, task_data in pairs(tm.task_info) do
                    -- Check if task has this NPC as target
                    if task_data.target_id and task_data.target_id == npc_id then
                        return true
                    end
                    -- Check task type for escort-related tasks
                    if task_data.type and (task_data.type == "escort" or task_data.type == "defend") then
                        if task_data.npc_id and task_data.npc_id == npc_id then
                            return true
                        end
                    end
                end
            end
        end
        return false
    end)
    if ok and result then return true end
    
    -- Check if NPC is in actor's squad (temporary companion via task)
    local ok2, result2 = pcall(function()
        if db.actor and get_object_squad then
            local actor_squad = get_object_squad(db.actor)
            if actor_squad then
                for member in actor_squad:squad_members() do
                    if member and member.id == npc_id then
                        return true
                    end
                end
            end
        end
        return false
    end)
    if ok2 and result2 then return true end
    
    -- Check for reach_task scheme (NPC following actor for quest)
    local ok3, result3 = pcall(function()
        if npc.get_script_params then
            local st = npc:get_script_params()
            if st and st.active_scheme == "reach_task" then
                return true
            end
        end
        return false
    end)
    if ok3 and result3 then return true end
    
    return false
end

-- Check if NPC should have anomaly damage ENABLED at engine level
-- Returns false for NPCs that should NEVER take damage (callback won't fire)
-- Returns true for NPCs that MIGHT take damage (callback will fire, then we roll)
-- Returns: enabled (bool), reason (string)
-- Note: Caller must verify npc is valid, alive, and IsStalker before calling
local function should_enable_anomaly_damage(npc)
    local community = npc:character_community()
    
    -- Full ignore - no damage (greh)
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false, "full_ignore_community"
    end
    
    -- No damage communities - they evade but don't take damage (monolith)
    if zz_allc0r3_mai_npc_settings.mai_no_damage_community[community] then
        return false, "no_damage_community"
    end
    
    -- Important NPCs - no damage
    if is_ignore_npc(npc) then 
        return false, "ignore_npc"
    end
    
    -- Companions - no damage
    if is_companion_npc(npc) then 
        return false, "companion"
    end
    
    -- Task/escort targets - no damage
    if is_task_target_npc(npc) then
        return false, "task_target"
    end
    
    -- Everyone else can take damage (zombied, stalkers, etc.)
    -- The actual damage is determined by roll in should_npc_take_damage()
    return true, "normal"
end

-- Check if NPC should get pathfinding restrictions (try to avoid anomalies)
-- Returns false for NPCs that should walk into anomalies
-- Note: Caller must verify npc is valid, alive, and IsStalker before calling
local function should_add_restrictions(npc)
    local community = npc:character_community()
    
    -- Full ignore - no restrictions (greh)
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false
    end
    
    -- No evade communities - no restrictions, walk straight into anomalies (zombied)
    if zz_allc0r3_mai_npc_settings.mai_no_evade_community[community] then
        return false
    end
    
    -- Important NPCs - no restrictions (they're protected anyway)
    if is_ignore_npc(npc) then return false end
    
    -- Companions - no restrictions (they follow player, restrictions might interfere)
    if is_companion_npc(npc) then return false end
    
    -- Task targets - no restrictions (they need to follow player/path)
    if is_task_target_npc(npc) then return false end
    
    -- Everyone else gets restrictions (monolith, stalkers, etc.)
    return true
end

-- Configure NPC anomaly interaction based on community/status
local function configure_npc_anomaly_interaction(npc)
    if not npc or not npc:alive() then return end
    if not IsStalker(npc) then return end
    
    local should_damage, reason = should_enable_anomaly_damage(npc)
    npc:set_enable_anomalies_damage(should_damage)
    
    dbg_verbose("CONFIG", "NPC [%s] community [%s] damage=%s (%s)", 
        npc:name(), npc:character_community(), tostring(should_damage), reason)
end

--------------------------------------------------------------------------------
-- Rank and Movement State
--------------------------------------------------------------------------------

-- Cached rank settings (avoid recreating tables on every call)
local RANK_MCM_KEYS = {
    ["novice"] = "rank_novice_miss_chance",
    ["trainee"] = "rank_trainee_miss_chance",
    ["experienced"] = "rank_experienced_miss_chance",
    ["professional"] = "rank_professional_miss_chance",
    ["veteran"] = "rank_veteran_miss_chance",
    ["expert"] = "rank_expert_miss_chance",
    ["master"] = "rank_master_miss_chance",
    ["legend"] = "rank_legend_miss_chance"
}

local RANK_DEFAULTS = {
    ["novice"] = 100,
    ["trainee"] = 75,
    ["experienced"] = 50,
    ["professional"] = 25,
    ["veteran"] = 0,
    ["expert"] = 0,
    ["master"] = 0,
    ["legend"] = 0
}

function get_rank_miss_chance(npc)
    if not npc then return 50 end
    
    local rank = ranks and ranks.get_se_obj_rank_name(npc) or nil
    if not rank then rank = "novice" end
    
    local setting_key = RANK_MCM_KEYS[rank] or "rank_novice_miss_chance"
    local default_val = RANK_DEFAULTS[rank] or 100
    
    return get_mcm_setting(setting_key, default_val)
end

local function get_movement_state_multiplier(npc)
    if not npc then return 1.0 end
    
    -- Combat check first (highest priority)
    if npc:best_enemy() then
        return get_mcm_setting("combat_miss_multiplier", 3.0)
    end
    
    local movement = npc:movement_type()
    
    if movement == move.stand then
        return get_mcm_setting("standing_miss_multiplier", 0.3)
    elseif movement == move.walk then
        return get_mcm_setting("walking_miss_multiplier", 0.6)
    elseif movement == move.run then
        return get_mcm_setting("running_miss_multiplier", 1.2)
    end
    
    return 1.0
end

local function get_movement_state_name(npc)
    if not npc then return "unknown" end
    if npc:best_enemy() then return "combat" end
    
    local movement = npc:movement_type()
    if movement == move.stand then return "standing"
    elseif movement == move.walk then return "walking"
    elseif movement == move.run then return "running"
    end
    return "unknown"
end

--------------------------------------------------------------------------------
-- Pathfinding Restrictions
--------------------------------------------------------------------------------

-- Track NPC positions to detect if they're stuck
local npc_positions = {}
local npc_stuck_count = {}
local npc_unstuck_until = {}  -- Track when NPC can receive restrictions again

local UNSTUCK_COOLDOWN = 20000  -- 20 seconds before NPC can get restrictions again after being unstuck

local function get_nearby_anomalies(npc_pos, radius)
    local result = {}
    for _, anom in ipairs(anomaly_cache) do
        local dist = anom.pos:distance_to(npc_pos)
        if dist <= radius then
            ti(result, anom.name)
        end
    end
    return result
end

-- Check if NPC is stuck (hasn't moved significantly)
local function check_npc_stuck(npc, current_pos)
    local id = npc:id()
    local last_pos = npc_positions[id]
    
    if not last_pos then
        npc_positions[id] = current_pos
        npc_stuck_count[id] = 0
        return false
    end
    
    local distance_moved = last_pos:distance_to(current_pos)
    npc_positions[id] = current_pos
    
    -- If NPC moved less than 0.5 meters, increment stuck counter
    if distance_moved < 0.5 then
        npc_stuck_count[id] = (npc_stuck_count[id] or 0) + 1
    else
        npc_stuck_count[id] = 0
    end
    
    -- Consider stuck after 5 consecutive checks with no movement (10 seconds)
    return npc_stuck_count[id] >= 5
end

-- Clear restrictions for NPC
local function clear_npc_restrictions(npc)
    if not npc then return end
    
    local current_restrictions = npc:in_restrictions() or ""
    if current_restrictions ~= "" then
        pcall(function()
            npc:remove_restrictions("", current_restrictions)
        end)
        dbg_log("STUCK", "Cleared restrictions for stuck NPC [%s]", npc:name())
    end
    
    -- Reset stuck counter
    local id = npc:id()
    npc_stuck_count[id] = 0
end

local function update_npc_restrictions(npc, detection_radius)
    if not should_add_restrictions(npc) then return end
    
    local id = npc:id()
    local current_time = time_global()
    
    -- Throttle per-NPC updates
    if npc_last_update[id] and current_time - npc_last_update[id] < 1000 then
        return
    end
    npc_last_update[id] = current_time
    
    local npc_pos = npc:position()
    local radius = detection_radius or get_mcm_setting("base_detection_radius", 30)
    local nearby = get_nearby_anomalies(npc_pos, radius)
    
    -- No nearby anomalies - reset tracking
    if #nearby == 0 then
        npc_stuck_count[id] = 0
        npc_positions[id] = nil
        npc_unstuck_until[id] = nil
        return
    end
    
    -- NPC is near anomalies - check if still in unstuck cooldown
    if npc_unstuck_until[id] and current_time < npc_unstuck_until[id] then
        -- Still in cooldown, don't add restrictions
        return
    end
    
    -- Cooldown expired, clear it
    npc_unstuck_until[id] = nil
    
    -- Check if NPC is stuck
    if check_npc_stuck(npc, npc_pos) then
        clear_npc_restrictions(npc)
        -- Set cooldown - NPC won't get new restrictions for 20 seconds
        npc_unstuck_until[id] = current_time + UNSTUCK_COOLDOWN
        dbg_log("STUCK", "NPC [%s] unstuck, cooldown for 20s", npc:name())
        return
    end
    
    -- Get current restrictions
    local current_restrictions = npc:in_restrictions() or ""
    local max_len = get_mcm_setting("max_restrictions_length", 2048)
    
    -- If restrictions are getting too long, clear some old ones
    if current_restrictions:len() > max_len * 0.8 then
        dbg_log("RESTRICT", "NPC [%s] restrictions near limit (%d), clearing", 
            npc:name(), current_restrictions:len())
        clear_npc_restrictions(npc)
        current_restrictions = ""
    end
    
    -- Find anomalies not already in restrictions
    local to_add = {}
    for _, anom_name in ipairs(nearby) do
        if not sf(current_restrictions, anom_name) then
            -- Roll for miss based on rank
            local miss_chance = get_rank_miss_chance(npc)
            local state_mult = get_movement_state_multiplier(npc)
            local final_chance = math.floor(miss_chance * state_mult)
            
            if final_chance <= 0 or rd(1, 100) > final_chance then
                -- NPC detects this anomaly (roll > chance means success)
                ti(to_add, anom_name)
            else
                dbg_log("DETECT", "NPC [%s] missed anomaly [%s] (roll <= %d%%)", 
                    npc:name(), anom_name, final_chance)
            end
        end
    end
    
    -- Add new restrictions
    if #to_add > 0 then
        local add_str = tc(to_add, ",")
        if current_restrictions:len() + add_str:len() + 1 < max_len then
            npc:add_restrictions("", add_str)
            dbg_log("RESTRICT", "NPC [%s] added %d restrictions: %s", 
                npc:name(), #to_add, add_str)
        end
    end
end

--------------------------------------------------------------------------------
-- Damage System
--------------------------------------------------------------------------------

function should_npc_take_damage(npc, anomaly)
    if not npc or not anomaly then return true end
    
    -- Note: Community checks (greh, monolith), companion checks, and important NPC checks
    -- are now handled at engine level via set_enable_anomalies_damage(false)
    -- This callback only fires for NPCs that CAN take damage
    
    -- Always skip during surge
    if surge_started() then
        dbg_log("DAMAGE", "Surge active, blocking damage to [%s]", npc:name())
        return false
    end
    
    -- Check if anomaly should be skipped
    local anom_name = anomaly:name()
    if is_always_skip_anomaly(anom_name) then
        return false
    end
    
    -- Get rank miss chance once (used multiple times below)
    local miss_chance = get_rank_miss_chance(npc)
    
    -- Immunity for 0% miss chance (veterans+)
    if get_mcm_setting("immune_zero_miss_chance", true) then
        if miss_chance == 0 then
            dbg_log("DAMAGE", "NPC [%s] immune (0%% miss chance), blocking damage", npc:name())
            return false
        end
    end
    
    -- Roll for damage based on rank + state
    local state_mult = get_movement_state_multiplier(npc)
    local damage_chance = math.floor(miss_chance * state_mult)
    
    -- Higher miss_chance = more likely to take damage
    -- Novice running in combat: 100 * 3.0 = 300% (capped at 100) = always takes damage
    -- Veteran standing: 0 * 0.3 = 0% = never takes damage
    
    if damage_chance > 100 then damage_chance = 100 end
    
    local roll = rd(1, 100)
    local takes_damage = roll <= damage_chance
    
    local state = get_movement_state_name(npc)
    local rank = ranks and ranks.get_se_obj_rank_name(npc) or "unknown"
    
    if takes_damage then
        dbg_log("DAMAGE", "NPC [%s] (rank: %s, state: %s) HIT by [%s] (roll: %d <= %d%%)", 
            npc:name(), rank, state, anom_name, roll, damage_chance)
    else
        dbg_log("DAMAGE", "NPC [%s] (rank: %s, state: %s) AVOIDED [%s] (roll: %d > %d%%)", 
            npc:name(), rank, state, anom_name, roll, damage_chance)
    end
    
    return takes_damage
end

--------------------------------------------------------------------------------
-- Armor Protection System
--------------------------------------------------------------------------------

-- Map anomaly patterns to protection stats (for pattern matching)
local ANOMALY_PROTECTION_PATTERNS = {
    -- Electric anomalies
    { pattern = "electra",      protection = "shock_protection" },
    { pattern = "electric",     protection = "shock_protection" },
    { pattern = "tesla",        protection = "shock_protection" },
    { pattern = "static",       protection = "shock_protection" },
    
    -- Thermal/Fire anomalies
    { pattern = "burner",       protection = "burn_protection" },
    { pattern = "thermal",      protection = "burn_protection" },
    { pattern = "fire",         protection = "burn_protection" },
    { pattern = "inferno",      protection = "burn_protection" },
    { pattern = "zharka",       protection = "burn_protection" },
    
    -- Chemical/Acid anomalies
    { pattern = "acidic",       protection = "chemical_burn_protection" },
    { pattern = "chemical",     protection = "chemical_burn_protection" },
    { pattern = "gas",          protection = "chemical_burn_protection" },
    { pattern = "fruit_punch",  protection = "chemical_burn_protection" },
    
    -- Gravity anomalies
    { pattern = "gravitational", protection = "strike_protection" },
    { pattern = "springboard",   protection = "strike_protection" },
    { pattern = "vortex",        protection = "strike_protection" },
    { pattern = "whirligig",     protection = "strike_protection" },
    { pattern = "galantine",     protection = "strike_protection" },
    { pattern = "tramplin",      protection = "strike_protection" },
    
    -- Radiation anomalies
    { pattern = "radioactive",  protection = "radiation_protection" },
    { pattern = "radiation",    protection = "radiation_protection" },
    
    -- Psy anomalies
    { pattern = "psy",          protection = "telepatic_protection" },
    { pattern = "brain",        protection = "telepatic_protection" },
    { pattern = "telepatic",    protection = "telepatic_protection" },
}

-- Cache for already-resolved anomaly sections (O(1) lookup after first hit)
local anomaly_protection_cache = {}

-- Get protection type for an anomaly
local function get_anomaly_protection_type(anomaly_section)
    if not anomaly_section then return nil end
    
    -- Check cache first
    local cached = anomaly_protection_cache[anomaly_section]
    if cached ~= nil then
        return cached ~= false and cached or nil
    end
    
    -- Pattern match and cache result
    local section_lower = anomaly_section:lower()
    for _, mapping in ipairs(ANOMALY_PROTECTION_PATTERNS) do
        if sf(section_lower, mapping.pattern) then
            anomaly_protection_cache[anomaly_section] = mapping.protection
            return mapping.protection
        end
    end
    
    -- Cache negative result too (false means "no match found")
    anomaly_protection_cache[anomaly_section] = false
    return nil
end

-- Get NPC's outfit protection value
local function get_npc_outfit_protection(npc, protection_type)
    if not npc or not protection_type then return 0 end
    
    -- Try to get outfit from slot 7 (outfit slot)
    local outfit = npc:item_in_slot(7)
    if not outfit then 
        dbg_verbose("ARMOR", "NPC [%s] has no outfit", npc:name())
        return 0 
    end
    
    local outfit_section = outfit:section()
    if not outfit_section then return 0 end
    
    -- Read protection value from outfit config
    local protection = SYS_GetParam(2, outfit_section, protection_type, 0)
    
    dbg_verbose("ARMOR", "NPC [%s] outfit [%s] %s = %.3f", 
        npc:name(), outfit_section, protection_type, protection)
    
    return protection or 0
end

function get_npc_dmg_mult(npc, anomaly)
    if not npc then return 1.0 end
    
    -- Check if armor damage multipliers enabled
    if not get_mcm_setting("enable_armor_damage_mult", true) then
        return 1.0
    end
    
    if not anomaly then return 1.0 end
    
    local anomaly_section = anomaly:section()
    if not anomaly_section then return 1.0 end
    
    -- Get protection type for this anomaly
    local protection_type = get_anomaly_protection_type(anomaly_section)
    if not protection_type then
        dbg_verbose("ARMOR", "Unknown anomaly type [%s], using full damage", anomaly_section)
        return 1.0
    end
    
    -- Get NPC's protection value
    local protection = get_npc_outfit_protection(npc, protection_type)
    
    -- Convert protection to damage multiplier
    -- protection = 0.0 → mult = 1.0 (full damage)
    -- protection = 0.5 → mult = 0.5 (half damage)
    -- protection = 1.0 → mult = 0.0 (no damage)
    -- protection > 1.0 → mult = negative (healing? cap at 0)
    local damage_mult = math.max(0, 1.0 - protection)
    
    dbg_verbose("ARMOR", "Anomaly [%s] → %s → protection %.2f → damage mult %.2f",
        anomaly_section, protection_type, protection, damage_mult)
    
    return damage_mult
end

--------------------------------------------------------------------------------
-- Surge Detection
--------------------------------------------------------------------------------

function surge_started()
    return (surge_manager and surge_manager.is_loaded() and surge_manager.is_started()) or
           (psi_storm_manager and psi_storm_manager.is_loaded() and psi_storm_manager.is_started())
end

--------------------------------------------------------------------------------
-- Map Marker Cleanup (for old versions)
--------------------------------------------------------------------------------

local function cleanup_old_map_markers()
    local count = 0
    for i = 1, 65534 do
        if level.map_has_object_spot(i, "anomaly_disabled") ~= 0 then
            level.map_remove_object_spot(i, "anomaly_disabled")
            count = count + 1
        end
    end
    
    if count > 0 then
        printf("[MAI] Cleaned up %d old map markers", count)
        dbg_verbose("CLEANUP", "Removed %d old anomaly map markers", count)
    end
    
    return count
end

-- Called when MCM option changes
local function on_option_change()
    update_mcm_cache()
    
    -- Check if cleanup was requested
    if get_mcm_setting("cleanup_map_markers", false) then
        cleanup_old_map_markers()
        -- Reset the checkbox (user needs to manually set it again)
        -- Note: This doesn't actually reset MCM, just our internal state
    end
end

--------------------------------------------------------------------------------
-- Global Update Loop
--------------------------------------------------------------------------------

-- Check if current level should be ignored
local function is_ignore_level()
    local current_level = level.name()
    return zz_allc0r3_mai_location_settings and 
           zz_allc0r3_mai_location_settings.mai_always_ignore_levels and
           zz_allc0r3_mai_location_settings.mai_always_ignore_levels[current_level]
end

local function on_actor_update()
    if not is_mod_enabled() then 
        dbg_verbose("UPDATE", "Mod disabled, skipping")
        return 
    end
    if surge_started() then 
        dbg_verbose("UPDATE", "Surge active, skipping")
        return 
    end
    
    -- Check if db.actor is valid
    if not db.actor then 
        dbg_verbose("UPDATE", "No db.actor, skipping")
        return 
    end
    
    -- Skip ignored levels (underground labs, etc.)
    if is_ignore_level() then 
        dbg_verbose("UPDATE", "Level ignored: %s", level.name())
        return 
    end
    
    local current_time = time_global()
    if current_time < global_update_timer then return end
    
    global_update_timer = current_time + UPDATE_INTERVAL
    
    -- Ensure cache is valid
    ensure_cache()
    
    -- Cache MCM settings for this update cycle
    local effect_radius = get_mcm_setting("effect_radius", 300)
    local restrictions_ignore_radius = get_mcm_setting("restrictions_ignore_radius", true)
    local detection_radius = get_mcm_setting("base_detection_radius", 30)
    local actor_pos = db.actor:position()
    
    -- Count NPCs for debug
    local npc_count = 0
    local processed_count = 0
    
    -- Update all online stalkers
    for id, npc in pairs(db.OnlineStalkers) do
        npc_count = npc_count + 1
        -- some mods store just the id here
        if type(npc) == "number" then
            npc = level.object_by_id(npc)
        end

        -- Skip anything that is still not a valid game object
        if npc and npc.alive and npc:alive() and IsStalker(npc) then
            local npc_pos = npc:position()
            local distance = npc_pos:distance_to(actor_pos)
            local within_radius = distance <= effect_radius
            
            -- Damage: configure based on community only within radius
            -- Outside radius: always protect NPC from damage
            if within_radius then
                configure_npc_anomaly_interaction(npc)
            else
                npc:set_enable_anomalies_damage(false)
            end
            
            -- Restrictions: apply within radius, or everywhere if setting enabled
            if within_radius or restrictions_ignore_radius then
                update_npc_restrictions(npc, detection_radius)
            end
            
            processed_count = processed_count + 1
        end
    end
    
    -- Log once per update cycle if we processed NPCs
    if processed_count > 0 then
        dbg_verbose("UPDATE", "Processed %d/%d NPCs (cache: %d anomalies)", 
            processed_count, npc_count, #anomaly_cache)
    end
end

--------------------------------------------------------------------------------
-- Callbacks
--------------------------------------------------------------------------------

-- Delay cache rebuild to allow Arrival mod to finish respawning anomalies
-- Arrival uses: 0.5s delay for cleanup + 0.3s delay for spawn + queue processing

local function schedule_cache_rebuild(reason)
    local delay = get_mcm_setting("cache_rebuild_delay", 2.5)
    dbg_verbose("EVENT", "%s, scheduling cache rebuild in %.1fs", reason, delay)
    
    -- Cancel any pending rebuild
    RemoveTimeEvent("mai_cache_rebuild", "mai_cache_rebuild")
    
    -- If delay is 0, rebuild immediately
    if delay <= 0 then
        invalidate_cache()
        return
    end
    
    -- Schedule new rebuild with delay
    CreateTimeEvent("mai_cache_rebuild", "mai_cache_rebuild", delay, function()
        dbg_verbose("EVENT", "Executing delayed cache rebuild")
        invalidate_cache()
        return true
    end)
end

local function on_surge_end()
    schedule_cache_rebuild("Surge ended")
end

local function on_psy_storm_end()
    schedule_cache_rebuild("Psy-storm ended")
end

local function on_game_load()
    dbg_verbose("EVENT", "Game loaded, rebuilding cache")
    
    -- Enable anomaly damage for AI globally at engine level
    exec_console_cmd("ai_die_in_anomaly 1")
    dbg_verbose("EVENT", "Enabled ai_die_in_anomaly 1")
    
    invalidate_cache()
    npc_last_update = {} -- Clear throttle tracking
    npc_positions = {}   -- Clear position tracking
    npc_stuck_count = {} -- Clear stuck counters
    npc_unstuck_until = {} -- Clear unstuck cooldowns
end

local function on_level_changed()
    dbg_verbose("EVENT", "Level changed, invalidating cache")
    invalidate_cache()
    npc_last_update = {}
    npc_positions = {}
    npc_stuck_count = {}
    npc_unstuck_until = {}
end

-- Cleanup when NPC goes offline
local function on_npc_net_destroy(npc)
    local id
    if type(npc) == "number" then
        id = npc
    else
        id = npc:id()
        -- Try to remove restrictions before NPC goes offline
        if npc and npc.remove_restrictions then
            pcall(function()
                npc:remove_restrictions("", npc:in_restrictions() or "")
            end)
        end
    end
    npc_last_update[id] = nil
    npc_positions[id] = nil
    npc_stuck_count[id] = nil
    npc_unstuck_until[id] = nil
end

-- Configure NPC when it spawns online
local function on_npc_net_spawn(npc)
    if not is_mod_enabled() then return end
    if not npc then return end
    if not IsStalker(npc) then return end
    if not npc:alive() then return end
    
    -- Skip ignored levels (check once, same result as update loop will get)
    if is_ignore_level() then return end
    
    -- Skip if no anomalies cached on this level
    if #anomaly_cache == 0 and cache_valid then return end
    
    -- Configure damage settings immediately
    configure_npc_anomaly_interaction(npc)
    
    dbg_verbose("SPAWN", "NPC [%s] spawned, configured anomaly interaction", npc:name())
end

--------------------------------------------------------------------------------
-- Initialization
--------------------------------------------------------------------------------

function on_game_start()
    printf("[MAI] Initializing MAI v2.0...")
    
    update_mcm_cache()
    printf("[MAI] MCM cache updated - mod_enabled=%s, debug_mode=%s", 
        tostring(cached_mod_enabled), tostring(cached_debug_mode))
    
    -- Core callbacks
    RegisterScriptCallback("actor_on_update", on_actor_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("npc_on_net_destroy", on_npc_net_destroy)
    RegisterScriptCallback("npc_on_net_spawn", on_npc_net_spawn)
    
    -- Cache invalidation callbacks
    RegisterScriptCallback("surge_manager_end_surge", on_surge_end)
    RegisterScriptCallback("psi_storm_manager_end_storm", on_psy_storm_end)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_first_update", on_game_load)
    RegisterScriptCallback("actor_on_level_changed", on_level_changed)
    
    local arrival_status = is_arrival_loaded() and "detected" or "not detected"
    printf("[MAI] v2.0 loaded successfully - Arrival: %s", arrival_status)
end
