--[[
    MAI (Mutant/Anomaly Interaction) by AllC0r3
    Version: 3.0 - Performance Rewrite
    
    Features:
    - Lightweight anomaly cache (rebuilt only after surge/psy-storm)
    - Simple pathfinding restrictions (no per-NPC session tracking)
    - Damage roll based on rank + movement state
    - Arrival mod compatibility
    
    Design:
    - Cache anomalies once after surge, reuse until next surge
    - Single global update loop for all NPCs
    - No subscribe/unsubscribe system
    - Damage callback decides if NPC should take damage
--]]

--------------------------------------------------------------------------------
-- Local aliases for performance
--------------------------------------------------------------------------------

local sf = string.find
local ti = table.insert
local tc = table.concat
local rd = math.random

--------------------------------------------------------------------------------
-- Module variables
--------------------------------------------------------------------------------

-- Anomaly cache - rebuilt after each surge/psy-storm
local anomaly_cache = {}
local cache_valid = false
local cache_level = nil

-- Global update timer
local global_update_timer = 0
local UPDATE_INTERVAL = 2000 -- Check all NPCs every 2 seconds

-- Debug flag cache
local cached_debug_mode = false
local cached_mod_enabled = true

-- Track last restriction add time per NPC to avoid spam
local npc_last_update = {}

--------------------------------------------------------------------------------
-- MCM Integration
--------------------------------------------------------------------------------

local function get_mcm_setting(key, default)
    if zz_allc0r3_mai_mcm then
        local getter = zz_allc0r3_mai_mcm["get_config"]
        if getter then
            local val = getter(key)
            if val ~= nil then return val end
        end
    end
    return default
end

local function is_mod_enabled() return cached_mod_enabled end
local function is_debug_enabled() return cached_debug_mode end

local function update_mcm_cache()
    cached_mod_enabled = get_mcm_setting("mod_enabled", true)
    cached_debug_mode = get_mcm_setting("debug_mode", false)
end

--------------------------------------------------------------------------------
-- Debug Logging
--------------------------------------------------------------------------------

local function dbg_log(category, format, ...)
    if not is_debug_enabled() then return end
    local msg = string.format(format, ...)
    printf("[%s][MAI][%s] %s", time_global(), category, msg)
end

--------------------------------------------------------------------------------
-- Arrival Mod Compatibility
--------------------------------------------------------------------------------

local arrival_checked = false
local arrival_loaded = false

local function is_arrival_loaded()
    if not arrival_checked then
        arrival_loaded = arrival_zone_disable ~= nil and 
                        arrival_zone_disable.zd_spawn and
                        arrival_zone_disable.zd_spawn.zones_to_disable
        arrival_checked = true
    end
    return arrival_loaded
end

local function is_arrival_anomaly_active(anom_id, level_name)
    if not is_arrival_loaded() then return true end
    
    local zones_to_disable = arrival_zone_disable.zd_spawn.zones_to_disable
    if not zones_to_disable then return true end
    
    local level_zones = zones_to_disable[level_name]
    if not level_zones then return true end
    
    -- If anomaly ID is in the disable list, it's disabled
    if level_zones[anom_id] then
        return false
    end
    
    return true
end

local function is_anomaly_enabled(anomaly_obj)
    if not anomaly_obj then return false end
    
    -- Check common anomaly disable methods
    local cls = anomaly_obj:clsid()
    
    -- Try to check if anomaly is disabled via game flag
    if anomaly_obj.disabled and anomaly_obj:disabled() then
        return false
    end
    
    -- Check if anomaly has no "online" state
    local se_obj = alife_object(anomaly_obj:id())
    if se_obj and se_obj.disabled then
        return false
    end
    
    return true
end

--------------------------------------------------------------------------------
-- Anomaly Cache System
--------------------------------------------------------------------------------

local function is_always_skip_anomaly(anom_name)
    local t = zz_allc0r3_mai_anomalies_settings.mai_always_ignore_anom
    for i = 1, #t do
        if anom_name == t[i] or sf(anom_name, t[i]) then return true end
    end
    return false
end

local function rebuild_anomaly_cache()
    anomaly_cache = {}
    local level_name = level.name()
    cache_level = level_name
    
    local fields = bind_anomaly_field.fields_by_names
    if not fields then 
        dbg_log("CACHE", "No anomaly fields found")
        cache_valid = true
        return 
    end
    
    local count = 0
    local skipped = 0
    local arrival_loaded_now = is_arrival_loaded()
    
    for _, v in pairs(fields) do
        local anom_obj = v.object
        if anom_obj then
            local anom_id = anom_obj:id()
            local se_obj = alife_object(anom_id)
            
            if se_obj then
                local anom_name = se_obj:name()
                
                -- Skip always-ignored anomalies
                if is_always_skip_anomaly(anom_name) then
                    skipped = skipped + 1
                else
                    -- Check Arrival mod
                    local is_active = true
                    if arrival_loaded_now then
                        is_active = is_arrival_anomaly_active(anom_id, level_name)
                    end
                    
                    if is_active then
                        ti(anomaly_cache, {
                            id = anom_id,
                            name = anom_name,
                            pos = anom_obj:position(),
                            section = se_obj:section_name()
                        })
                        count = count + 1
                    else
                        skipped = skipped + 1
                    end
                end
            end
        end
    end
    
    cache_valid = true
    dbg_log("CACHE", "Rebuilt anomaly cache: %d anomalies, %d skipped (level: %s)", count, skipped, level_name)
    printf("[MAI] Anomaly cache rebuilt: %d anomalies on %s", count, level_name)
end

local function invalidate_cache()
    cache_valid = false
    dbg_log("CACHE", "Cache invalidated")
end

local function ensure_cache()
    local current_level = level.name()
    if not cache_valid or cache_level ~= current_level then
        rebuild_anomaly_cache()
    end
end

--------------------------------------------------------------------------------
-- NPC Checks
--------------------------------------------------------------------------------

local function is_ignore_npc(npc)
    local id = npc:id()
    local section = npc:section()
    local profile = npc:profile_name()
    
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[section] then
        return true
    end
    if zz_allc0r3_mai_npc_settings.demonized_ignore_npc[profile] then
        return true
    end
    if get_object_story_id(id) then
        return true
    end
    if IsTrader(npc) then
        return true
    end
    return false
end

local function is_companion_npc(npc)
    return npc and npc:has_info("npcx_is_companion")
end

local function should_ignore_npc(npc)
    if not npc or not npc:alive() then return true end
    if not IsStalker(npc) then return true end
    
    local community = npc:character_community()
    
    -- Check community ignore settings
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return true
    end
    
    if is_ignore_npc(npc) then return true end
    if is_companion_npc(npc) then return true end
    
    return false
end

--------------------------------------------------------------------------------
-- Rank and Movement State
--------------------------------------------------------------------------------

function get_rank_miss_chance(npc)
    if not npc then return 50 end
    
    local rank = ranks.get_se_obj_rank_name(npc)
    if not rank then rank = "novice" end
    
    local rank_settings = {
        ["novice"] = "rank_novice_miss_chance",
        ["trainee"] = "rank_trainee_miss_chance",
        ["experienced"] = "rank_experienced_miss_chance",
        ["professional"] = "rank_professional_miss_chance",
        ["veteran"] = "rank_veteran_miss_chance",
        ["expert"] = "rank_expert_miss_chance",
        ["master"] = "rank_master_miss_chance",
        ["legend"] = "rank_legend_miss_chance"
    }
    
    local defaults = {
        ["novice"] = 100,
        ["trainee"] = 75,
        ["experienced"] = 50,
        ["professional"] = 25,
        ["veteran"] = 0,
        ["expert"] = 0,
        ["master"] = 0,
        ["legend"] = 0
    }
    
    local setting_key = rank_settings[rank] or "rank_novice_miss_chance"
    local default_val = defaults[rank] or 100
    
    return get_mcm_setting(setting_key, default_val)
end

local function get_movement_state_multiplier(npc)
    if not npc then return 1.0 end
    
    -- Combat check first (highest priority)
    if npc:best_enemy() then
        return get_mcm_setting("combat_miss_multiplier", 3.0)
    end
    
    local movement = npc:movement_type()
    
    if movement == move.stand then
        return get_mcm_setting("standing_miss_multiplier", 0.3)
    elseif movement == move.walk then
        return get_mcm_setting("walking_miss_multiplier", 0.6)
    elseif movement == move.run then
        return get_mcm_setting("running_miss_multiplier", 1.2)
    end
    
    return 1.0
end

local function get_movement_state_name(npc)
    if not npc then return "unknown" end
    if npc:best_enemy() then return "combat" end
    
    local movement = npc:movement_type()
    if movement == move.stand then return "standing"
    elseif movement == move.walk then return "walking"
    elseif movement == move.run then return "running"
    end
    return "unknown"
end

--------------------------------------------------------------------------------
-- Pathfinding Restrictions
--------------------------------------------------------------------------------

local function get_nearby_anomalies(npc_pos, radius)
    local result = {}
    for _, anom in ipairs(anomaly_cache) do
        local dist = anom.pos:distance_to(npc_pos)
        if dist <= radius then
            ti(result, anom.name)
        end
    end
    return result
end

local function update_npc_restrictions(npc)
    if should_ignore_npc(npc) then return end
    
    local id = npc:id()
    local current_time = time_global()
    
    -- Throttle per-NPC updates
    if npc_last_update[id] and current_time - npc_last_update[id] < 1000 then
        return
    end
    npc_last_update[id] = current_time
    
    local npc_pos = npc:position()
    local radius = get_mcm_setting("base_detection_radius", 30)
    local nearby = get_nearby_anomalies(npc_pos, radius)
    
    if #nearby == 0 then return end
    
    -- Get current restrictions
    local current_restrictions = npc:in_restrictions() or ""
    local max_len = get_mcm_setting("max_restrictions_length", 2048)
    
    -- Find anomalies not already in restrictions
    local to_add = {}
    for _, anom_name in ipairs(nearby) do
        if not sf(current_restrictions, anom_name) then
            -- Roll for miss based on rank
            local miss_chance = get_rank_miss_chance(npc)
            local state_mult = get_movement_state_multiplier(npc)
            local final_chance = math.floor(miss_chance * state_mult)
            
            if final_chance <= 0 or rd(1, 100) > final_chance then
                -- NPC detects this anomaly (roll > chance means success)
                ti(to_add, anom_name)
            else
                dbg_log("DETECT", "NPC [%s] missed anomaly [%s] (roll <= %d%%)", 
                    npc:name(), anom_name, final_chance)
            end
        end
    end
    
    -- Add new restrictions
    if #to_add > 0 then
        local add_str = tc(to_add, ",")
        if current_restrictions:len() + add_str:len() + 1 < max_len then
            npc:add_restrictions("", add_str)
            dbg_log("RESTRICT", "NPC [%s] added %d restrictions: %s", 
                npc:name(), #to_add, add_str)
        end
    end
end

--------------------------------------------------------------------------------
-- Damage System
--------------------------------------------------------------------------------

function should_npc_take_damage(npc, anomaly)
    if not npc or not anomaly then return true end
    
    -- Always skip during surge
    if surge_started() then
        dbg_log("DAMAGE", "Surge active, blocking damage to [%s]", npc:name())
        return false
    end
    
    -- Check if anomaly should be skipped
    local anom_name = anomaly:name()
    if is_always_skip_anomaly(anom_name) then
        return false
    end
    
    -- Check community settings
    local community = npc:character_community()
    if zz_allc0r3_mai_npc_settings.mai_always_full_ignore_community[community] then
        return false
    end
    
    -- Companions don't take anomaly damage
    if is_companion_npc(npc) then
        return false
    end
    
    -- Important NPCs don't take anomaly damage
    if is_ignore_npc(npc) then
        return false
    end
    
    -- Immunity for 0% miss chance (veterans+)
    if get_mcm_setting("immune_zero_miss_chance", true) then
        local miss_chance = get_rank_miss_chance(npc)
        if miss_chance == 0 then
            dbg_log("DAMAGE", "NPC [%s] immune (0%% miss chance), blocking damage", npc:name())
            return false
        end
    end
    
    -- Roll for damage based on rank + state
    local miss_chance = get_rank_miss_chance(npc)
    local state_mult = get_movement_state_multiplier(npc)
    local damage_chance = math.floor(miss_chance * state_mult)
    
    -- Higher miss_chance = more likely to take damage
    -- Novice running in combat: 100 * 3.0 = 300% (capped at 100) = always takes damage
    -- Veteran standing: 0 * 0.3 = 0% = never takes damage
    
    if damage_chance > 100 then damage_chance = 100 end
    
    local roll = rd(1, 100)
    local takes_damage = roll <= damage_chance
    
    local state = get_movement_state_name(npc)
    local rank = ranks.get_se_obj_rank_name(npc) or "unknown"
    
    if takes_damage then
        dbg_log("DAMAGE", "NPC [%s] (rank: %s, state: %s) HIT by [%s] (roll: %d <= %d%%)", 
            npc:name(), rank, state, anom_name, roll, damage_chance)
    else
        dbg_log("DAMAGE", "NPC [%s] (rank: %s, state: %s) AVOIDED [%s] (roll: %d > %d%%)", 
            npc:name(), rank, state, anom_name, roll, damage_chance)
    end
    
    return takes_damage
end

function get_npc_dmg_mult(npc, anomaly)
    if not npc then return 1.0 end
    
    -- Check if visual damage multipliers enabled
    if not get_mcm_setting("enable_visual_damage_mult", true) then
        return 1.0
    end
    
    -- Get visual settings for this NPC's armor
    local visual = npc:get_visual_name()
    local visual_settings = zz_allc0r3_mai_npc_settings.mai_npc_settings
    
    if visual_settings then
        for pattern, settings in pairs(visual_settings) do
            if sf(visual, pattern) then
                local anomaly_section = anomaly:section()
                for anom_pattern, mult in pairs(settings.damage_mult or {}) do
                    if sf(anomaly_section, anom_pattern) then
                        return mult
                    end
                end
                return settings.damage_mult_default or 1.0
            end
        end
    end
    
    return 1.0
end

--------------------------------------------------------------------------------
-- Surge Detection
--------------------------------------------------------------------------------

function surge_started()
    return (surge_manager and surge_manager.is_loaded() and surge_manager.is_started()) or
           (psi_storm_manager and psi_storm_manager.is_loaded() and psi_storm_manager.is_started())
end

--------------------------------------------------------------------------------
-- Global Update Loop
--------------------------------------------------------------------------------

local function on_actor_update()
    if not is_mod_enabled() then return end
    if surge_started() then return end
    
    local current_time = time_global()
    if current_time < global_update_timer then return end
    
    global_update_timer = current_time + UPDATE_INTERVAL
    
    -- Ensure cache is valid
    ensure_cache()
    
    -- Update all online stalkers
    local count = 0
    for id, npc in pairs(db.OnlineStalkers) do
        -- some mods store just the id here
        if type(npc) == "number" then
            npc = level.object_by_id(npc)
        end

        -- Skip anything that is still not a valid game object
        if npc and npc.alive and npc:alive() and IsStalker(npc) then
            update_npc_restrictions(npc)
            count = count + 1
        end
    end
end

--------------------------------------------------------------------------------
-- Callbacks
--------------------------------------------------------------------------------

local function on_surge_end()
    dbg_log("EVENT", "Surge ended, rebuilding cache")
    invalidate_cache()
end

local function on_psy_storm_end()
    dbg_log("EVENT", "Psy-storm ended, rebuilding cache")
    invalidate_cache()
end

local function on_game_load()
    dbg_log("EVENT", "Game loaded, rebuilding cache")
    invalidate_cache()
    npc_last_update = {} -- Clear throttle tracking
end

local function on_level_changed()
    dbg_log("EVENT", "Level changed, invalidating cache")
    invalidate_cache()
    npc_last_update = {}
end

local function on_option_change()
    update_mcm_cache()
end

-- Cleanup when NPC goes offline
local function on_npc_net_destroy(npc)
    if npc then
        npc_last_update[npc:id()] = nil
    end
end

--------------------------------------------------------------------------------
-- Initialization
--------------------------------------------------------------------------------

function on_game_start()
    update_mcm_cache()
    
    -- Core callbacks
    RegisterScriptCallback("actor_on_update", on_actor_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("npc_on_net_destroy", on_npc_net_destroy)
    
    -- Cache invalidation callbacks
    RegisterScriptCallback("surge_manager_end_surge", on_surge_end)
    RegisterScriptCallback("psi_storm_manager_end_storm", on_psy_storm_end)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_first_update", on_game_load)
    RegisterScriptCallback("actor_on_level_changed", on_level_changed)
    
    local arrival_status = is_arrival_loaded() and "detected" or "not detected"
    printf("[MAI] v3.0 loaded (lightweight) - Arrival: %s", arrival_status)
end